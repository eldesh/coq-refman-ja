<!DOCTYPE html>
<html class="writer-html5" lang="ja" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>仕様記述言語 Gallina &mdash; Coq 8.8.2 ドキュメント</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/fonts.css" type="text/css" />
      <link rel="stylesheet" href="../_static/ansi.css" type="text/css" />
      <link rel="stylesheet" href="../_static/coqdoc.css" type="text/css" />
      <link rel="stylesheet" href="../_static/notations.css" type="text/css" />
      <link rel="stylesheet" href="../_static/pre-text.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/notations.js"></script>
        <script src="../_static/translations.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="next" title="Gallina の拡張" href="gallina-extensions.html" />
    <link rel="prev" title="Credits" href="../credits.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Coq
          </a>
              <div class="version">
                8.8.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">索引</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-cmdindex.html">Command index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-tacindex.html">Tactic index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-optindex.html">Flags, options and tables index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-exnindex.html">Errors and warnings index</a></li>
</ul>
<p class="caption"><span class="caption-text">はじめに</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">はじめに</a></li>
<li class="toctree-l1"><a class="reference internal" href="../credits.html">Credits</a></li>
</ul>
<p class="caption"><span class="caption-text">言語</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">仕様記述言語 Gallina</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#about-the-grammars-in-the-manual">マニュアル中の文法について</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lexical-conventions">字句規則</a></li>
<li class="toctree-l2"><a class="reference internal" href="#terms">Terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#syntax-of-terms">項の構文</a></li>
<li class="toctree-l3"><a class="reference internal" href="#types">型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#qualified-identifiers-and-simple-identifiers">量化識別子と単純識別子</a></li>
<li class="toctree-l3"><a class="reference internal" href="#numerals">数字</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sorts">Sorts</a></li>
<li class="toctree-l3"><a class="reference internal" href="#binders">束縛子</a></li>
<li class="toctree-l3"><a class="reference internal" href="#abstractions">抽象</a></li>
<li class="toctree-l3"><a class="reference internal" href="#products">積</a></li>
<li class="toctree-l3"><a class="reference internal" href="#applications">適用</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-cast">型キャスト</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inferable-subterms">推論可能 部分項</a></li>
<li class="toctree-l3"><a class="reference internal" href="#let-in-definitions">Let-in 定義</a></li>
<li class="toctree-l3"><a class="reference internal" href="#definition-by-case-analysis">場合分けによる定義</a></li>
<li class="toctree-l3"><a class="reference internal" href="#recursive-functions">再帰関数</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-vernacular">The Vernacular</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#assumptions">Assumptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inductive-definitions">Inductive definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#simple-inductive-types">Simple inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#simple-annotated-inductive-types">Simple annotated inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#parametrized-inductive-types">Parametrized inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#variants">Variants</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mutually-defined-inductive-types">Mutually defined inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#co-inductive-types">Co-inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#definition-of-recursive-functions">Definition of recursive functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#definition-of-functions-by-recursion-over-inductive-objects">Definition of functions by recursion over inductive objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="#definitions-of-recursive-objects-in-co-inductive-types">Definitions of recursive objects in co-inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#assertions-and-proofs">Assertions and proofs</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="gallina-extensions.html"><span class="smallcaps">Gallina</span> の拡張</a></li>
<li class="toctree-l1"><a class="reference internal" href="coq-library.html">The <span class="smallcaps">Coq</span> library</a></li>
<li class="toctree-l1"><a class="reference internal" href="cic.html">Calculus of Inductive Constructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="module-system.html">The Module System</a></li>
</ul>
<p class="caption"><span class="caption-text">証明エンジン</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/vernacular-commands.html">Vernacular commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/proof-handling.html">Proof handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/tactics.html">Tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/ltac.html">The tactic language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/detailed-tactic-examples.html">Detailed examples of tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html">The <span class="smallcaps">SSReflect</span> proof language</a></li>
</ul>
<p class="caption"><span class="caption-text">ユーザ拡張</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/syntax-extensions.html">Syntax extensions and interpretation scopes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/proof-schemes.html">Proof schemes</a></li>
</ul>
<p class="caption"><span class="caption-text">実用ツール</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coq-commands.html">The <span class="smallcaps">Coq</span> commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/utilities.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coqide.html"><span class="smallcaps">Coq</span> Integrated Development Environment</a></li>
</ul>
<p class="caption"><span class="caption-text">付録</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../addendum/extended-pattern-matching.html">Extended pattern matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/implicit-coercions.html">Implicit Coercions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/canonical-structures.html">正準構造</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/type-classes.html">型クラス</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/omega.html">Omega: a solver for quantifier-free problems in Presburger Arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/micromega.html">Micromega: tactics for solving arithmetic goals over ordered rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/extraction.html">Extraction of programs in <span class="smallcaps">OCaml</span> and Haskell</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/program.html">Program</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/ring.html">The ring and field tactic families</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/nsatz.html">Nsatz: tactics for proving equalities in integral domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/generalized-rewriting.html">Generalized rewriting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/parallel-proof-processing.html">Asynchronous and Parallel Proof Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/miscellaneous-extensions.html">Miscellaneous extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/universe-polymorphism.html">Polymorphic Universes</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../zebibliography.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Coq</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>仕様記述言語 Gallina</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/coq/coq/blob/master/doc/sphinx/language/gallina-specification-language.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="math-preamble math notranslate nohighlight">
\[\begin{split}\newcommand{\alors}{\textsf{then}}
\newcommand{\alter}{\textsf{alter}}
\newcommand{\as}{\kw{as}}
\newcommand{\Assum}[3]{\kw{Assum}(#1)(#2:#3)}
\newcommand{\bool}{\textsf{bool}}
\newcommand{\case}{\kw{case}}
\newcommand{\conc}{\textsf{conc}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\conshl}{\textsf{cons\_hl}}
\newcommand{\Def}[4]{\kw{Def}(#1)(#2:=#3:#4)}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\EqSt}{\textsf{EqSt}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\false}{\textsf{false}}
\newcommand{\filter}{\textsf{filter}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\from}{\textsf{from}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\haslength}{\textsf{has\_length}}
\newcommand{\hd}{\textsf{hd}}
\newcommand{\ident}{\textsf{ident}}
\newcommand{\In}{\kw{in}}
\newcommand{\Ind}[4]{\kw{Ind}[#2](#3:=#4)}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[5]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)}
\newcommand{\Indpstr}[6]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)/{#6}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\lb}{\lambda}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\Prod}{\textsf{prod}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\si}{\textsf{if}}
\newcommand{\sinon}{\textsf{else}}
\newcommand{\Sort}{\cal S}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\true}{\textsf{true}}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\unfold}{\textsf{unfold}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\cal W\!F}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\cal W\!F}(#2)}
\newcommand{\WFTWOLINES}[2]{{\cal W\!F}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\newcommand{\zeros}{\textsf{zeros}}
\end{split}\]</div>
<div class="section" id="the-gallina-specification-language">
<span id="gallinaspecificationlanguage"></span><h1>仕様記述言語 Gallina<a class="headerlink" href="#the-gallina-specification-language" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>この章では Coq の仕様記述言語である Gallina について記述します。それは数学的な定理を開発したりプログラムの仕様を証明することが出来ます. 定理とは公理、仮定、パラメータ、補題、定理や定数、関数、命題の定義、それに集合から構築されます。定理に含まれている論理オブジェクトの構文は <a class="reference internal" href="#term"><span class="std std-ref">Terms</span></a> の節で述べられています。そのコマンド言語は <em>Vernacular</em> と呼ばれ、<a class="reference internal" href="#vernacular"><span class="std std-ref">The Vernacular</span></a> の節で説明されます。</p>
<p>Coq では、論理オブジェクトはそれらの論理的整合性を保証するために型付けられます。その規則は型付けアルゴリズムによって実装され、<a class="reference internal" href="cic.html#calculusofinductiveconstructions"><span class="std std-ref">Calculus of Inductive Constructions</span></a> の章で述べられています。</p>
<div class="section" id="about-the-grammars-in-the-manual">
<h2>マニュアル中の文法について<a class="headerlink" href="#about-the-grammars-in-the-manual" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>文法はバッカスナウアー記法 (BNF)で与えられます。終端記号は黒の <code class="docutils literal notranslate"><span class="pre">タイプライター体</span></code> で表されます。さらに、正規表現については特別な記法があります。</p>
<p>角カッコ <code class="docutils literal notranslate"><span class="pre">[…]</span></code> で囲まれた式はこの式が最大一で度だけ出現することを意味します (これはオプショナルな部品に対応します)。</p>
<p>“<code class="docutils literal notranslate"><span class="pre">entry</span> <span class="pre">sep</span> <span class="pre">…</span> <span class="pre">sep</span> <span class="pre">entry</span></code>” という記法はエントリーでパースされリテラル “<code class="docutils literal notranslate"><span class="pre">sep</span></code>” <a class="footnote-reference brackets" href="#id6" id="id1">1</a> で分割された式の非空の列を表します。</p>
<p>同じように、 “<code class="docutils literal notranslate"><span class="pre">entry</span> <span class="pre">…</span> <span class="pre">entry</span></code>” という記法は間にセパレータ無しに “<code class="docutils literal notranslate"><span class="pre">entry</span></code>” エントリーによってパースされた非空の列を表します。</p>
<p>最後に、 “<code class="docutils literal notranslate"><span class="pre">[entry</span> <span class="pre">sep</span> <span class="pre">…</span> <span class="pre">sep</span> <span class="pre">entry]</span></code>” という記法は “<code class="docutils literal notranslate"><span class="pre">entry</span></code>” エントリーによってパースされリテラル “<code class="docutils literal notranslate"><span class="pre">sep</span></code>” によって分割された空になり得る式の列を表します。</p>
</div>
<div class="section" id="lexical-conventions">
<span id="id2"></span><h2>字句規則<a class="headerlink" href="#lexical-conventions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl>
<dt>空白</dt><dd><p>スペース、改行、水平タブは空白とみなされます。空白は無視されますが、トークンを分割します。</p>
</dd>
<dt>コメント</dt><dd><p>Coq のコメントは <code class="docutils literal notranslate"><span class="pre">(*</span></code> と <code class="docutils literal notranslate"><span class="pre">*)</span></code> の間に囲まれ、ネストできます。それは任意の文字を含むことができます。しかしながら、<a class="reference internal" href="#grammar-token-string"><code class="xref std std-token docutils literal notranslate"><span class="pre">string</span></code></a> リテラルは正しく閉じられていなければなりません。コメントは空白として扱われます。</p>
</dd>
<dt>識別子とアクセス識別子</dt><dd><p>識別子は <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> と書かれ、文字、数字、<code class="docutils literal notranslate"><span class="pre">_</span></code>、<code class="docutils literal notranslate"><span class="pre">'</span></code> の列であり、数字や <code class="docutils literal notranslate"><span class="pre">'</span></code> から始まることはありません。つまり、以下の字句クラスで認識されます。</p>
<pre>
<strong id="grammar-token-first-letter">first_letter     </strong> ::=  a..z ∣ A..Z ∣ _ ∣ unicode-letter
<strong id="grammar-token-subsequent-letter">subsequent_letter</strong> ::=  a..z ∣ A..Z ∣ 0..9 ∣ _ ∣ ' ∣ unicode-letter ∣ unicode-id-part
<strong id="grammar-token-ident">ident            </strong> ::=  <a class="reference internal" href="#grammar-token-first-letter"><code class="xref docutils literal notranslate"><span class="pre">first_letter</span></code></a>[<a class="reference internal" href="#grammar-token-subsequent-letter"><code class="xref docutils literal notranslate"><span class="pre">subsequent_letter</span></code></a>…<a class="reference internal" href="#grammar-token-subsequent-letter"><code class="xref docutils literal notranslate"><span class="pre">subsequent_letter</span></code></a>]
<strong id="grammar-token-access-ident">access_ident     </strong> ::=  .<a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a>
</pre>
<p>全ての文字には意味があります。特に、識別子はケースセンシティブです。<code class="docutils literal notranslate"><span class="pre">unicode-letter</span></code> エントリは非網羅的にラテン語、ギリシャ語、ドイツ語、キリル文字、アラビア語、ヘブライ語、グルジア語、ハングル、ひらがなとカタカナ、CJK 表意文字、記号やハイフンやハードスペースのような数学記号、… を含んでいます。<code class="docutils literal notranslate"><span class="pre">unicode-id-part</span></code> エントリは非網羅的にプライム文字や下付き文字を含みます。</p>
<p>アクセス識別子は、<a class="reference internal" href="#grammar-token-access-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">access_ident</span></code></a> と書かれ、空白無しに <cite>.</cite> (ドット) が接頭辞になる識別子です。それらは修飾された識別子の構文で使われます。</p>
</dd>
<dt>自然数と整数</dt><dd><p>数の表示は数字の列です。整数は数の表記に任意にマイナス記号が前に付いたものです。</p>
<pre>
<strong id="grammar-token-digit">digit  </strong> ::=  0..9
<strong id="grammar-token-num">num    </strong> ::=  <a class="reference internal" href="#grammar-token-digit"><code class="xref docutils literal notranslate"><span class="pre">digit</span></code></a>…<a class="reference internal" href="#grammar-token-digit"><code class="xref docutils literal notranslate"><span class="pre">digit</span></code></a>
<strong id="grammar-token-integer">integer</strong> ::=  [-]<a class="reference internal" href="#grammar-token-num"><code class="xref docutils literal notranslate"><span class="pre">num</span></code></a>
</pre>
</dd>
<dt>文字列</dt><dd><p>文字列は <code class="docutils literal notranslate"><span class="pre">&quot;</span></code> (ダブルクォート) で区切られ、<code class="docutils literal notranslate"><span class="pre">&quot;</span></code> やダブルクォート文字を表すための列である <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> と異なる任意の文字の並びを囲んだものです。文法規則では、クォートされた文字列のエントリが <span class="inline-grammar-production"><span class="target" id="grammar-token-string"></span><code class="docutils literal notranslate"><span class="pre">string</span></code></span> です。</p>
</dd>
<dt>キーワード</dt><dd><p>以下の識別子は予約済みキーワードであり、他のものには使えません:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>_ as at cofix else end exists exists2 fix for
forall fun if IF in let match mod Prop return
Set then Type using where with
</pre></div>
</div>
</dd>
<dt>スペシャルトークン</dt><dd><p>以下の文字の列はスペシャルトークンです:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>! % &amp; &amp;&amp; ( () ) * + ++ , - -&gt; . .( ..
/ /\ : :: :&lt; := :&gt; ; &lt; &lt;- &lt;-&gt; &lt;: &lt;= &lt;&gt; =
=&gt; =_D &gt; &gt;-&gt; &gt;= ? ?= @ [ \/ ] ^ { | |-
|| } ~
</pre></div>
</div>
<p>字句的な曖昧さは “最長マッチ” 規則に沿って解決されます: アルファベットや数字でない文字の列が幾つかの異なる方法で分離される時には、したがって最初のトークンは (その瞬間に定義されている全てのトークンの中で) 最長の可能なものなどになります。</p>
</dd>
</dl>
</div>
<div class="section" id="terms">
<span id="term"></span><h2>Terms<a class="headerlink" href="#terms" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="syntax-of-terms">
<h3>項の構文<a class="headerlink" href="#syntax-of-terms" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下の文法は <em>Calculus of Inductive Constructions</em> (Cic とも呼ばれる) の項の基本的な構文を記述します。Cic の形式的な表現は章 <a class="reference internal" href="cic.html#calculusofinductiveconstructions"><span class="std std-ref">Calculus of Inductive Constructions</span></a> で与えられます。この構文の拡張は章 <a class="reference internal" href="gallina-extensions.html#extensionsofgallina"><span class="std std-ref">Gallina の拡張</span></a> で与えられます。構文のカスタマイズの方法は章 <a class="reference internal" href="../user-extensions/syntax-extensions.html#syntaxextensionsandinterpretationscopes"><span class="std std-ref">Syntax extensions and interpretation scopes</span></a> で説明されます。</p>
<pre>
<strong id="grammar-token-term">term        </strong> ::=  forall <a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a> , <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                  | fun <a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a> =&gt; <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                  | fix <a class="reference internal" href="#grammar-token-fix-bodies"><code class="xref docutils literal notranslate"><span class="pre">fix_bodies</span></code></a>
                  | cofix <a class="reference internal" href="#grammar-token-cofix-bodies"><code class="xref docutils literal notranslate"><span class="pre">cofix_bodies</span></code></a>
                  | let <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> [<a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a>] [: <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>] := <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> in <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                  | let fix <a class="reference internal" href="#grammar-token-fix-body"><code class="xref docutils literal notranslate"><span class="pre">fix_body</span></code></a> in <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                  | let cofix <a class="reference internal" href="#grammar-token-cofix-body"><code class="xref docutils literal notranslate"><span class="pre">cofix_body</span></code></a> in <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                  | let ( [<a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal notranslate"><span class="pre">name</span></code></a> , … , <a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal notranslate"><span class="pre">name</span></code></a>] ) [<a class="reference internal" href="#grammar-token-dep-ret-type"><code class="xref docutils literal notranslate"><span class="pre">dep_ret_type</span></code></a>] := <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> in <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                  | let ' <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a> [in <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>] := <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> [<a class="reference internal" href="#grammar-token-return-type"><code class="xref docutils literal notranslate"><span class="pre">return_type</span></code></a>] in <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                  | if <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> [<a class="reference internal" href="#grammar-token-dep-ret-type"><code class="xref docutils literal notranslate"><span class="pre">dep_ret_type</span></code></a>] then <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> else <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                  | <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> : <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                  | <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> &lt;: <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                  | <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> :&gt;
                  | <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> -&gt; <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                  | <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> <a class="reference internal" href="#grammar-token-arg"><code class="xref docutils literal notranslate"><span class="pre">arg</span></code></a> … <a class="reference internal" href="#grammar-token-arg"><code class="xref docutils literal notranslate"><span class="pre">arg</span></code></a>
                  | &#64; <a class="reference internal" href="#grammar-token-qualid"><code class="xref docutils literal notranslate"><span class="pre">qualid</span></code></a> [<a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> … <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>]
                  | <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> % <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a>
                  | match <a class="reference internal" href="#grammar-token-match-item"><code class="xref docutils literal notranslate"><span class="pre">match_item</span></code></a> , … , <a class="reference internal" href="#grammar-token-match-item"><code class="xref docutils literal notranslate"><span class="pre">match_item</span></code></a> [<a class="reference internal" href="#grammar-token-return-type"><code class="xref docutils literal notranslate"><span class="pre">return_type</span></code></a>] with
                    [[|] <a class="reference internal" href="#grammar-token-equation"><code class="xref docutils literal notranslate"><span class="pre">equation</span></code></a> | … | <a class="reference internal" href="#grammar-token-equation"><code class="xref docutils literal notranslate"><span class="pre">equation</span></code></a>] end
                  | <a class="reference internal" href="#grammar-token-qualid"><code class="xref docutils literal notranslate"><span class="pre">qualid</span></code></a>
                  | <a class="reference internal" href="#grammar-token-sort"><code class="xref docutils literal notranslate"><span class="pre">sort</span></code></a>
                  | <a class="reference internal" href="#grammar-token-num"><code class="xref docutils literal notranslate"><span class="pre">num</span></code></a>
                  | _
                  | ( <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> )
<strong id="grammar-token-arg">arg         </strong> ::=  <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                  | ( <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> := <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> )
<strong id="grammar-token-binders">binders     </strong> ::=  <a class="reference internal" href="#grammar-token-binder"><code class="xref docutils literal notranslate"><span class="pre">binder</span></code></a> … <a class="reference internal" href="#grammar-token-binder"><code class="xref docutils literal notranslate"><span class="pre">binder</span></code></a>
<strong id="grammar-token-binder">binder      </strong> ::=  <a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal notranslate"><span class="pre">name</span></code></a>
                  | ( <a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal notranslate"><span class="pre">name</span></code></a> … <a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal notranslate"><span class="pre">name</span></code></a> : <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> )
                  | ( <a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal notranslate"><span class="pre">name</span></code></a> [: <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>] := <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> )
                  | ' <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a>
<strong id="grammar-token-name">name        </strong> ::=  <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> | _
<strong id="grammar-token-qualid">qualid      </strong> ::=  <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> | <a class="reference internal" href="#grammar-token-qualid"><code class="xref docutils literal notranslate"><span class="pre">qualid</span></code></a> <a class="reference internal" href="#grammar-token-access-ident"><code class="xref docutils literal notranslate"><span class="pre">access_ident</span></code></a>
<strong id="grammar-token-sort">sort        </strong> ::=  Prop | Set | Type
<strong id="grammar-token-fix-bodies">fix_bodies  </strong> ::=  <a class="reference internal" href="#grammar-token-fix-body"><code class="xref docutils literal notranslate"><span class="pre">fix_body</span></code></a>
                  | <a class="reference internal" href="#grammar-token-fix-body"><code class="xref docutils literal notranslate"><span class="pre">fix_body</span></code></a> with <a class="reference internal" href="#grammar-token-fix-body"><code class="xref docutils literal notranslate"><span class="pre">fix_body</span></code></a> with … with <a class="reference internal" href="#grammar-token-fix-body"><code class="xref docutils literal notranslate"><span class="pre">fix_body</span></code></a> for <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a>
<strong id="grammar-token-cofix-bodies">cofix_bodies</strong> ::=  <a class="reference internal" href="#grammar-token-cofix-body"><code class="xref docutils literal notranslate"><span class="pre">cofix_body</span></code></a>
                  | <a class="reference internal" href="#grammar-token-cofix-body"><code class="xref docutils literal notranslate"><span class="pre">cofix_body</span></code></a> with <a class="reference internal" href="#grammar-token-cofix-body"><code class="xref docutils literal notranslate"><span class="pre">cofix_body</span></code></a> with … with <a class="reference internal" href="#grammar-token-cofix-body"><code class="xref docutils literal notranslate"><span class="pre">cofix_body</span></code></a> for <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a>
<strong id="grammar-token-fix-body">fix_body    </strong> ::=  <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> <a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a> [<a class="reference internal" href="#grammar-token-annotation"><code class="xref docutils literal notranslate"><span class="pre">annotation</span></code></a>] [: <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>] := <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
<strong id="grammar-token-cofix-body">cofix_body  </strong> ::=  <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> [<a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a>] [: <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>] := <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
<strong id="grammar-token-annotation">annotation  </strong> ::=  { struct <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> }
<strong id="grammar-token-match-item">match_item  </strong> ::=  <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> [as <a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal notranslate"><span class="pre">name</span></code></a>] [in <a class="reference internal" href="#grammar-token-qualid"><code class="xref docutils literal notranslate"><span class="pre">qualid</span></code></a> [<a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a> … <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a>]]
<strong id="grammar-token-dep-ret-type">dep_ret_type</strong> ::=  [as <a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal notranslate"><span class="pre">name</span></code></a>] <a class="reference internal" href="#grammar-token-return-type"><code class="xref docutils literal notranslate"><span class="pre">return_type</span></code></a>
<strong id="grammar-token-return-type">return_type </strong> ::=  return <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
<strong id="grammar-token-equation">equation    </strong> ::=  <a class="reference internal" href="#grammar-token-mult-pattern"><code class="xref docutils literal notranslate"><span class="pre">mult_pattern</span></code></a> | … | <a class="reference internal" href="#grammar-token-mult-pattern"><code class="xref docutils literal notranslate"><span class="pre">mult_pattern</span></code></a> =&gt; <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
<strong id="grammar-token-mult-pattern">mult_pattern</strong> ::=  <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a> , … , <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a>
<strong id="grammar-token-pattern">pattern     </strong> ::=  <a class="reference internal" href="#grammar-token-qualid"><code class="xref docutils literal notranslate"><span class="pre">qualid</span></code></a> <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a> … <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a>
                  | &#64; <a class="reference internal" href="#grammar-token-qualid"><code class="xref docutils literal notranslate"><span class="pre">qualid</span></code></a> <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a> … <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a>
                  | <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a> as <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a>
                  | <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a> % <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a>
                  | <a class="reference internal" href="#grammar-token-qualid"><code class="xref docutils literal notranslate"><span class="pre">qualid</span></code></a>
                  | _
                  | <a class="reference internal" href="#grammar-token-num"><code class="xref docutils literal notranslate"><span class="pre">num</span></code></a>
                  | ( <a class="reference internal" href="#grammar-token-or-pattern"><code class="xref docutils literal notranslate"><span class="pre">or_pattern</span></code></a> , … , <a class="reference internal" href="#grammar-token-or-pattern"><code class="xref docutils literal notranslate"><span class="pre">or_pattern</span></code></a> )
<strong id="grammar-token-or-pattern">or_pattern  </strong> ::=  <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a> | … | <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a>
</pre>
</div>
<div class="section" id="types">
<h3>型<a class="headerlink" href="#types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Coq の項は型付けされます。Coq の型は <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> と同じ構文クラスと認識されます。<span class="inline-grammar-production"><span class="target" id="grammar-token-type"></span><code class="docutils literal notranslate"><span class="pre">type</span></code></span> によって <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> の構文クラスの中で意味論的なサブクラスの種類を表します。</p>
</div>
<div class="section" id="qualified-identifiers-and-simple-identifiers">
<span id="gallina-identifiers"></span><h3>量化識別子と単純識別子<a class="headerlink" href="#qualified-identifiers-and-simple-identifiers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><em>量化識別子</em> (<a class="reference internal" href="#grammar-token-qualid"><code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code></a>) は <em>グローバル定数</em> (定義、補題、定理、注意、事実)、<em>グローバル変数</em> (パラメータや公理)、<em>帰納的型</em> や <em>帰納的型のコンストラクタ</em> を表します。<em>単純識別子</em> (あるいは短く <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>) は量化識別子の構文的なサブセットです。識別子は <em>局所変数</em> も表すことがある一方、量化識別子はそうではありません。</p>
</div>
<div class="section" id="numerals">
<h3>数字<a class="headerlink" href="#numerals" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>計算の中で数字は確定された意味は持ちません。それらは表記法機構(詳しくは章 <a class="reference internal" href="../user-extensions/syntax-extensions.html#syntaxextensionsandinterpretationscopes"><span class="std std-ref">Syntax extensions and interpretation scopes</span></a> を参照)を通して(訳注: 数学的)対象に束縛され得る単なる記法にすぎません。初めは数字は自然数のペアノの表現に束縛されます(<a class="reference internal" href="coq-library.html#datatypes"><span class="std std-ref">Datatypes</span></a> を参照)。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>負の整数は <a class="reference internal" href="#grammar-token-num"><code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code></a> と同じレベルにはありません、このため優先順序が不自然になります。</p>
</div>
</div>
<div class="section" id="sorts">
<span id="index-0"></span><h3>Sorts<a class="headerlink" href="#sorts" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>3つのソート <code class="code Coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Set</span></span></code>、<code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>、<code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Type</span></span></code> があります。</p>
<ul class="simple">
<li><p><code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code> は <em>論理命題</em> の宇宙です。論理命題それ自体が証明を型付けます。命題は <span class="inline-grammar-production"><span class="target" id="grammar-token-form"></span><code class="docutils literal notranslate"><span class="pre">form</span></code></span> によって表します。これは <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> の構文クラスの意味論的なサブクラスを構成します。</p></li>
<li><p><code class="code Coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Set</span></span></code> は <em>プログラムの型</em> または <em>仕様</em> の宇宙です。その仕様それ自体がプログラムを型付けます。我々は仕様を <span class="inline-grammar-production"><span class="target" id="grammar-token-specif"></span><code class="docutils literal notranslate"><span class="pre">specif</span></code></span> で表します。これは <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> の構文クラスの意味論的なサブクラスを構成します。</p></li>
<li><p><code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Type</span></span></code> は <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code> と <code class="code Coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Set</span></span></code> の型です。</p></li>
</ul>
<p>ソートについてより詳しくは節 <a class="reference internal" href="cic.html#sorts"><span class="std std-ref">Sorts</span></a> で見つけることができます。</p>
</div>
<div class="section" id="binders">
<span id="id3"></span><h3>束縛子<a class="headerlink" href="#binders" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span></code>、<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span></code>、<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fix</span></span></code> それに <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">cofix</span></span></code> のような様々な構文が変数を <em>束縛</em> します。束縛は識別子によって表現されます。もし束縛変数がその式の中で使われないならば、その識別子は記号 <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">_</span></span></code> で置き換えることができます。束縛された変数の型がシステムによって生成出来ないときは、<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre"> : </span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span class="pre">)</span></span></span></code> という表記法によって指定することが出来ます。同じ型を共有する束縛変数の列のための表記法もあります: <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span><span><span class="pre"> : </span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span class="pre">)</span></span></span></code>。頭にクオートの付いたどんなパターンでも束縛子にすることが出来ます。例 <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">'</span></span><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">,</span></span><span class="name"><span class="pre">y</span></span><span class="operator"><span class="pre">)</span></span></code>。</p>
<p>幾つかの構文は変数の値への束縛が可能です。これは “let-束縛子” と呼ばれます。文法の <a class="reference internal" href="#grammar-token-binder"><code class="xref std std-token docutils literal notranslate"><span class="pre">binder</span></code></a> の項目は、上で定義された仮定束縛子または let-束縛子 のどちらかを受理します。後者の場合の表記法は <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre"> := </span></span><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">)</span></span></span></code> です。let-束縛子では、同時に高々一つの変数が導入できます。以下のように変数の型を与えることも出来ます: <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre"> : </span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span class="pre"> := </span></span><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">)</span></span></span></code> 。</p>
<p><a class="reference internal" href="#grammar-token-binder"><code class="xref std std-token docutils literal notranslate"><span class="pre">binder</span></code></a> のリストが認められます。<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span></code> と <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span></code> の場合は、リストの最低一つの束縛子が前提であることが意図されており、そうでなければ fun と forall は同一になります。さらに、同じ型を共有する束縛の単一の列の場合には、括弧も除去することが出来ます (例: <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">y</span></span> <span class="name"><span class="pre">z</span></span> <span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">=&gt;</span></span> <span class="name"><span class="pre">t</span></span></code> は <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">y</span></span> <span class="name"><span class="pre">z</span></span> <span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">=&gt;</span></span> <span class="name"><span class="pre">t</span></span></code> に短縮することができます)。</p>
</div>
<div class="section" id="abstractions">
<span id="index-1"></span><h3>抽象<a class="headerlink" href="#abstractions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>式 <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">fun</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a> <span><span class="pre">=&gt;</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> は項 <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> 上の型 <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> の変数 <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> の <em>抽象</em> を定義します。それは式 <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> へ評価する変数 <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> の関数を表します(例 <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span> <span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">=&gt;</span></span> <span class="name"><span class="pre">x</span></span></code> は型 <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code> 上の恒等関数を表します)。キーワード <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span></code> には節 <a class="reference internal" href="#binders"><span class="std std-ref">束縛子</span></a> で与えられるように幾つかの束縛子を続けることができます。複数の変数上の関数は1変数関数の反復と同等です。例えば式 “fun <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate nohighlight">\(_{1}\)</span> … <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate nohighlight">\(_{n}\)</span> : <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> =&gt; <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>” は “ fun <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate nohighlight">\(_{1}\)</span> : <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> =&gt; … fun <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate nohighlight">\(_{n}\)</span> : <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> =&gt; <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>” と同じ関数を表します。束縛子のリスト中に let-束縛子 が現れる場合、それは let-in 定義 (節 <a class="reference internal" href="#let-in"><span class="std std-ref">Let-in 定義</span></a> 参照) に展開されます。</p>
</div>
<div class="section" id="products">
<span id="index-2"></span><h3>積<a class="headerlink" href="#products" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>式 <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">forall </span></span><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre"> : </span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span class="pre">, </span></span><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> は項 <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> 上の型 <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> の変数 <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> の <em>積</em> を表します。抽象に関してはどうかというと、<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span></code> に束縛リストが続く場合や、いくつかの変数上の積は1変数積の繰り返しと同等です。留意すべきは <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> は型になることを意図されていることです。</p>
<p>変数 <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> が <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> 中に現れる場合、その積は <em>依存積</em> と呼ばれます。依存積 <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span> <span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">B</span></span></code> の背景にある意図には二つの側面があります。それは命題 <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code> 中での型 <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code> の変数 <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span></code> の全称量化または <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code> から <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code> への関数的依存積 (集合論では大抵 <span class="math notranslate nohighlight">\(\Pi_{x:A}.B\)</span> と書かれる構造) のどちらかを表します。</p>
<p>非依存積型は <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span> <span class="operator"><span class="pre">_</span></span> <span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">B</span></span></code> を表す特別記法 <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">B</span></span></code> を持ちます。その <em>非依存積</em> は包含命題と関数型の両方を表すのに使うことが出来ます。</p>
</div>
<div class="section" id="applications">
<h3>適用<a class="headerlink" href="#applications" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>式 <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate nohighlight">\(_0\)</span> <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate nohighlight">\(_1\)</span> は <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate nohighlight">\(_0\)</span> の <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate nohighlight">\(_1\)</span> への適用を表します。</p>
<p>式 <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate nohighlight">\(_0\)</span> <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate nohighlight">\(_1\)</span> ... <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate nohighlight">\(_n\)</span> は項 <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate nohighlight">\(_0\)</span> の引数 <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate nohighlight">\(_1\)</span> ...  <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate nohighlight">\(_n\)</span> への適用を表します。それは ( … ( <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate nohighlight">\(_0\)</span> <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate nohighlight">\(_1\)</span> ) … ) <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate nohighlight">\(_n\)</span> と同等で結合性は左です。</p>
<p>引数のための記法 <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre"> := </span></span><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">)</span></span></span></code> が暗黙引数の値を明示的にするために使われます (節 <a class="reference internal" href="gallina-extensions.html#explicit-applications"><span class="std std-ref">Explicit applications</span></a> を参照)。</p>
</div>
<div class="section" id="type-cast">
<span id="index-3"></span><h3>型キャスト<a class="headerlink" href="#type-cast" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>式 <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre"> : </span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> は型キャスト式です。それは <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> の型を <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> になるように強制します。</p>
<p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre"> &lt;: </span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> は <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> が型 <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> を持つことを検査するように局所的に仮想マシンを設定します。</p>
<p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre"> &lt;&lt;: </span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> 項 <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> が型 <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> も持つことを検査するためにネイティブコンパイルを使います。</p>
</div>
<div class="section" id="inferable-subterms">
<span id="index-4"></span><h3>推論可能 部分項<a class="headerlink" href="#inferable-subterms" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>しばしば式は冗長な情報の断片を含んでいます。部分項は Coq によって自動的に推論されることがあり、記号 <code class="docutils literal notranslate"><span class="pre">_</span></code> で置き換えると Coq が不足している情報の断片を推測します。</p>
</div>
<div class="section" id="let-in-definitions">
<span id="let-in"></span><span id="index-5"></span><h3>Let-in 定義<a class="headerlink" href="#let-in-definitions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">let</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">in</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">’</span></span></span></code> は <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>’ 内で <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> から変数 <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> への局所束縛を表します。関数の let-in 定義には糖衣構文があり、<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">let</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binder"><span class="hole"><span class="pre">binder</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">in</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">’</span></span></span></code> が <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">let</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:=</span></span> <span><span class="pre">fun</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binder"><span class="hole"><span class="pre">binder</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">=&gt;</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">in</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">’</span></span></span></code> を表します。</p>
</div>
<div class="section" id="definition-by-case-analysis">
<span id="index-6"></span><h3>場合分けによる定義<a class="headerlink" href="#definition-by-case-analysis" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>帰納型のオブジェクトはパターンマッチと呼ばれる場合分けの文法によって分解することができます。パターンマッチ式はある帰納オブジェクトの構造を解析し、特定の処理を適切に適用するために使われます。</p>
<p>この段落ではパターンマッチの基本形を説明します。一般形の説明については節 <a class="reference internal" href="gallina-extensions.html#mult-match"><span class="std std-ref">Multiple and nested pattern matching</span></a> と章 <a class="reference internal" href="../addendum/extended-pattern-matching.html#extendedpatternmatching"><span class="std std-ref">Extended pattern matching</span></a> を参照して下さい。パターンマッチの基本形は単一の <a class="reference internal" href="#grammar-token-match-item"><code class="xref std std-token docutils literal notranslate"><span class="pre">match_item</span></code></a> 式によって特徴づけられ、<a class="reference internal" href="#grammar-token-mult-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">mult_pattern</span></code></a> は単一の <a class="reference internal" href="#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a> に、<a class="reference internal" href="#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a> は <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span></span></code> という形式に制限されます。</p>
<p>&quot;<a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate nohighlight">\(_0\)</span> <a class="reference internal" href="#grammar-token-return-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">return_type</span></code></a> with <a class="reference internal" href="#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a><span class="math notranslate nohighlight">\(_1\)</span> =&gt; <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate nohighlight">\(_1\)</span> <span class="math notranslate nohighlight">\(|\)</span> … <span class="math notranslate nohighlight">\(|\)</span> <a class="reference internal" href="#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a><span class="math notranslate nohighlight">\(_n\)</span> =&gt; <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate nohighlight">\(_n\)</span> end&quot; にマッチする式は項 <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate nohighlight">\(_0\)</span> (帰納型 <span class="math notranslate nohighlight">\(I\)</span> になることが期待されます) 上の <em>パターンマッチング</em> を表します。項 <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate nohighlight">\(_1\)</span>…<a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate nohighlight">\(_n\)</span> はパターンマッチ式の <em>ブランチ</em> です。<a class="reference internal" href="#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a><span class="math notranslate nohighlight">\(_i\)</span> はそれぞれ <a class="reference internal" href="#grammar-token-qualid"><code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code></a> <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> という形式を持ち、ここで <a class="reference internal" href="#grammar-token-qualid"><code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code></a> はコンストラクタを表していなければなりません。全てのコンストラクタ <span class="math notranslate nohighlight">\(I\)</span> についてちょうど1つのブランチが存在しなくてはなりません。</p>
<p><a class="reference internal" href="#grammar-token-return-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">return_type</span></code></a> はマッチ式全体によって返される型を表します。幾つかのケースがあります。<em>非依存</em> ケースでは、全てのブランチは同じ型を持ち、<a class="reference internal" href="#grammar-token-return-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">return_type</span></code></a> はブランチの共通の型です。このケースでは、<a class="reference internal" href="#grammar-token-return-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">return_type</span></code></a> は通常ブランチの型から推論できるため省略されます <a class="footnote-reference brackets" href="#id7" id="id4">2</a>。</p>
<p><em>依存</em> ケースでは、3つのサブケースがあります。最初のサブケースでは、各ブランチ内の型はブランチ内で、マッチしたまさにその値に依存することができます。このケースでは、そのパターンマッチング全体それ自身がマッチされた項に依存します。このマッチされた項の返り型内の依存は、“as <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>” という節によって表されます。ここで <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> は返り型内での依存です。例えば、以下の例では:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">bool</span><span> : </span><span class="coqdoc-keyword">Type</span><span> := </span><span class="coqdoc-var">true</span><span> : </span><span class="coqdoc-var">bool</span><span> | </span><span class="coqdoc-var">false</span><span> : </span><span class="coqdoc-var">bool</span><span>.</span></dt><dd class="coqtop-hidden"><span>bool is defined
bool_rect is defined
bool_ind is defined
bool_rec is defined</span></dd>
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">eq</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Type</span><span>) (</span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">A</span><span>) : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span> := </span><span class="coqdoc-var">eq_refl</span><span> : </span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">x</span><span>.</span></dt><dd class="coqtop-hidden"><span>eq is defined
eq_rect is defined
eq_ind is defined
eq_rec is defined</span></dd>
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">or</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>) (</span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>) : </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
  | </span><span class="coqdoc-var">or_introl</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">or</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>
  | </span><span class="coqdoc-var">or_intror</span><span> : </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">or</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>.</span></dt><dd class="coqtop-hidden"><span>or is defined
or_ind is defined</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">bool_case</span><span> (</span><span class="coqdoc-var">b</span><span>:</span><span class="coqdoc-var">bool</span><span>) : </span><span class="coqdoc-var">or</span><span> (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">true</span><span>) (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">false</span><span>) :=</span><span>
  </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-keyword">as</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-keyword">return</span><span> </span><span class="coqdoc-var">or</span><span> (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">true</span><span>) (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">false</span><span>) </span><span class="coqdoc-keyword">with</span><span>
  | </span><span class="coqdoc-var">true</span><span> =&gt; </span><span class="coqdoc-var">or_introl</span><span> (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">true</span><span> </span><span class="coqdoc-var">true</span><span>) (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">true</span><span> </span><span class="coqdoc-var">false</span><span>) (</span><span class="coqdoc-var">eq_refl</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">true</span><span>)</span><span>
  | </span><span class="coqdoc-var">false</span><span> =&gt; </span><span class="coqdoc-var">or_intror</span><span> (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">false</span><span> </span><span class="coqdoc-var">true</span><span>) (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">false</span><span> </span><span class="coqdoc-var">false</span><span>) (</span><span class="coqdoc-var">eq_refl</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">false</span><span>)</span><span>
  </span><span class="coqdoc-keyword">end</span><span>.</span></dt><dd class="coqtop-hidden"><span>bool_case is defined</span></dd>
</dl>
</div>
<p>ブランチはそれぞれの型 &quot;<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">or</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">bool</span></span> <span class="name builtin pseudo"><span class="pre">true</span></span> <span class="name builtin pseudo"><span class="pre">true</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">bool</span></span> <span class="name builtin pseudo"><span class="pre">true</span></span> <span class="name builtin pseudo"><span class="pre">false</span></span><span class="operator"><span class="pre">)</span></span></code>&quot; と &quot;<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">or</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">bool</span></span> <span class="name builtin pseudo"><span class="pre">false</span></span> <span class="name builtin pseudo"><span class="pre">true</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">bool</span></span> <span class="name builtin pseudo"><span class="pre">false</span></span> <span class="name builtin pseudo"><span class="pre">false</span></span><span class="operator"><span class="pre">)</span></span></code>&quot; であり一方、パターンマッチング式全体は型 &quot;<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">or</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">bool</span></span> <span class="name"><span class="pre">b</span></span> <span class="name builtin pseudo"><span class="pre">true</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">bool</span></span> <span class="name"><span class="pre">b</span></span> <span class="name builtin pseudo"><span class="pre">false</span></span><span class="operator"><span class="pre">)</span></span></code>&quot; を持ち、識別子 <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">b</span></span></code> は依存を示すために使用されます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>項がマッチしたのが変数の時、<code class="docutils literal notranslate"><span class="pre">as</span></code> 節は省略でき、かつそのマッチした項は返り型内で束縛名としてそれ自身を提供することが出来ます。例えば、以下の替わりの定義は受け付けられ、以前のそれと同じ意味を持ちます。</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">bool_case</span><span> (</span><span class="coqdoc-var">b</span><span>:</span><span class="coqdoc-var">bool</span><span>) : </span><span class="coqdoc-var">or</span><span> (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">true</span><span>) (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">false</span><span>) :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-keyword">return</span><span> </span><span class="coqdoc-var">or</span><span> (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">true</span><span>) (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">false</span><span>) </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">true</span><span> =&gt; </span><span class="coqdoc-var">or_introl</span><span> (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">true</span><span> </span><span class="coqdoc-var">true</span><span>) (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">true</span><span> </span><span class="coqdoc-var">false</span><span>) (</span><span class="coqdoc-var">eq_refl</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">true</span><span>)</span><span>
| </span><span class="coqdoc-var">false</span><span> =&gt; </span><span class="coqdoc-var">or_intror</span><span> (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">false</span><span> </span><span class="coqdoc-var">true</span><span>) (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">false</span><span> </span><span class="coqdoc-var">false</span><span>) (</span><span class="coqdoc-var">eq_refl</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">false</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt><dd class="coqtop-hidden"><span>Toplevel input, characters 0-301:
&gt; Definition bool_case (b:bool) : or (eq bool b true) (eq bool b false) := match b return or (eq bool b true) (eq bool b false) with | true =&gt; or_introl (eq bool true true) (eq bool true false) (eq_refl bool true) | false =&gt; or_intror (eq bool false true) (eq bool false false) (eq_refl bool false) end.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> bool_case already exists.</span></dd>
</dl>
</div>
</div>
<p>二つ目のサブケースは等価性述語(節 <a class="reference internal" href="coq-library.html#coq-equality"><span class="std std-ref">Equality</span></a> 参照)や、自然数上の順序述語や、与えられた長さのリストの型(節 <a class="reference internal" href="../addendum/extended-pattern-matching.html#matching-dependent"><span class="std std-ref">Matching objects of dependent types</span></a> 参照)のような注釈付き帰納型にのみ関係します。この場合、各ブランチの型はそのブランチに固有の型の依存関係に依存することが出来、パターンマッチング式全体はマッチした項の型内の特定の依存関係によって決まる型を持ちます。帰納型の注釈内の返り型のこの依存性は &quot;<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">in</span></span></code> <span class="math notranslate nohighlight">\(I\)</span> <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">_</span></span> <span class="name builtin pseudo"><span class="pre">…</span></span> <span class="operator"><span class="pre">_</span></span></code> <a class="reference internal" href="#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a><span class="math notranslate nohighlight">\(_1\)</span> … <a class="reference internal" href="#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a><span class="math notranslate nohighlight">\(_n\)</span>” という節を使うことで表され、ここで</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(I\)</span> はマッチされた項の帰納型;</p></li>
<li><p><code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">_</span></span></code> はその帰納型のマッチするパラメータ：返り型はそれらに依存しない。</p></li>
<li><p><a class="reference internal" href="#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a><span class="math notranslate nohighlight">\(_i\)</span> はその帰納型の注釈にマッチする：返り型はそれに依存する。</p></li>
<li><p>以下で説明する基本的な場合には、各 <a class="reference internal" href="#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a><span class="math notranslate nohighlight">\(_i\)</span> は <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate nohighlight">\(_i\)</span> という名称になる; 一般の場合については <a class="reference internal" href="../addendum/extended-pattern-matching.html#match-in-patterns"><span class="std std-ref">Patterns in in</span></a> を参照。</p></li>
</ul>
<p>例えば、以下の例では:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">eq_sym</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Type</span><span>) (</span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>:</span><span class="coqdoc-var">A</span><span>) (</span><span class="coqdoc-var">H</span><span>:</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>) : </span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">x</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">H</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">z</span><span> </span><span class="coqdoc-keyword">return</span><span> </span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">z</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">eq_refl</span><span> </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-var">eq_refl</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">x</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt><dd class="coqtop-hidden"><span>Toplevel input, characters 105-114:
&gt; Definition eq_sym (A:Type) (x y:A) (H:eq A x y) : eq A y x := match H in eq _ _ z return eq A z x with | eq_refl _ =&gt; eq_refl A x end.
&gt;                                                                                                          ^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> The constructor </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">eq_refl</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (in type </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">eq</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) expects 2 arguments.</span></dd>
</dl>
</div>
<p>ブランチの型は <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">A</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">x</span></span></code> です。なぜなら <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">eq_refl</span></span></code> パターンの型の型内で <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">eq</span></span></code> の第3引数が <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span></code> となるためです。それに対して、パターンマッチング式全体の型は <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">A</span></span> <span class="name"><span class="pre">y</span></span> <span class="name"><span class="pre">x</span></span></code> を持ち、なぜなら H の型の eq の第3引数は y なためです。<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">eq</span></span></code> の第3引数内の場合分けのこの依存性は返り型の識別子 <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">z</span></span></code> によって表されます。</p>
<p>最後に、第3のケースは最初と2番目のケースの組み合わせです。特に、注釈付きの型の中でのパターンマッチにのみ適用されます。この3番目のケースでは、<code class="docutils literal notranslate"><span class="pre">as</span></code> と <code class="docutils literal notranslate"><span class="pre">in</span></code> 節の両方が利用できます。</p>
<p>一つまたは二つの構築子を持つ型上の場合分けのためには特別な記法があります： <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">…</span> <span class="pre">then</span> <span class="pre">…</span> <span class="pre">else</span> <span class="pre">…</span></code> と <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">(…,…)</span> <span class="pre">:=</span> <span class="pre">…</span> <span class="pre">in</span> <span class="pre">…</span></code> です。(節 <a class="reference internal" href="gallina-extensions.html#if-then-else"><span class="std std-ref">Pattern-matching on boolean values: the if expression</span></a> と <a class="reference internal" href="gallina-extensions.html#irrefutable-patterns"><span class="std std-ref">Irrefutable patterns: the destructuring let variants</span></a> 参照)。</p>
</div>
<div class="section" id="recursive-functions">
<span id="index-7"></span><h3>再帰関数<a class="headerlink" href="#recursive-functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>式 “<code class="docutils literal notranslate"><span class="pre">fix</span></code> <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate nohighlight">\(_1\)</span> <a class="reference internal" href="#grammar-token-binder"><code class="xref std std-token docutils literal notranslate"><span class="pre">binder</span></code></a><span class="math notranslate nohighlight">\(_1\)</span> <code class="docutils literal notranslate"><span class="pre">:</span></code> <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a><span class="math notranslate nohighlight">\(_1\)</span> <code class="docutils literal notranslate"><span class="pre">:=</span></code> <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate nohighlight">\(_1\)</span> <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">…</span> <span class="pre">with</span></code> <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate nohighlight">\(_n\)</span> <a class="reference internal" href="#grammar-token-binder"><code class="xref std std-token docutils literal notranslate"><span class="pre">binder</span></code></a><span class="math notranslate nohighlight">\(_n\)</span> : <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a><span class="math notranslate nohighlight">\(_n\)</span> <code class="docutils literal notranslate"><span class="pre">:=</span></code> <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate nohighlight">\(_n\)</span> <code class="docutils literal notranslate"><span class="pre">for</span></code> <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate nohighlight">\(_i\)</span>” は相互構造再帰により定義された関数のブロックのi番目のコンポーネントを表します。これはローカルの <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> コマンドに対応します。<span class="math notranslate nohighlight">\(n=1\)</span> のとき、“<code class="docutils literal notranslate"><span class="pre">for</span></code> <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate nohighlight">\(_i\)</span>” の節は省略されます。</p>
<p>式 “<code class="docutils literal notranslate"><span class="pre">cofix</span></code> <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate nohighlight">\(_1\)</span> <a class="reference internal" href="#grammar-token-binder"><code class="xref std std-token docutils literal notranslate"><span class="pre">binder</span></code></a><span class="math notranslate nohighlight">\(_1\)</span> <code class="docutils literal notranslate"><span class="pre">:</span></code> <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a><span class="math notranslate nohighlight">\(_1\)</span> <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">…</span> <span class="pre">with</span></code> <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate nohighlight">\(_n\)</span> <a class="reference internal" href="#grammar-token-binder"><code class="xref std std-token docutils literal notranslate"><span class="pre">binder</span></code></a><span class="math notranslate nohighlight">\(_n\)</span> : <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a><span class="math notranslate nohighlight">\(_n\)</span> <code class="docutils literal notranslate"><span class="pre">for</span></code> <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate nohighlight">\(_i\)</span>” は相互ガード付き余再帰により定義された項のブロックのi番目のコンポーネントを表します。これはローカルの <a class="reference internal" href="#coq:cmd.cofixpoint" title="CoFixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">CoFixpoint</span></code></a> コマンドに対応します。<span class="math notranslate nohighlight">\(n=1\)</span> のとき、“<code class="docutils literal notranslate"><span class="pre">for</span></code> <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate nohighlight">\(_i\)</span>” の節は省略されます。</p>
<p>単一の fixpoint と局所定義の関連付けは特別な構文を持ちます：<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">let</span></span> <span><span class="pre">fix</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a> <span><span class="pre">:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">in</span></span></span></code> は <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">let</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:=</span></span> <span><span class="pre">fix</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a> <span><span class="pre">:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">in</span></span></span></code> を表します。同等のものが co-fixpoint にも適用されます。</p>
</div>
</div>
<div class="section" id="the-vernacular">
<span id="vernacular"></span><h2>The Vernacular<a class="headerlink" href="#the-vernacular" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre>
<strong id="grammar-token-sentence">sentence          </strong> ::=  <a class="reference internal" href="#grammar-token-assumption"><code class="xref docutils literal notranslate"><span class="pre">assumption</span></code></a>
                        | <a class="reference internal" href="#grammar-token-definition"><code class="xref docutils literal notranslate"><span class="pre">definition</span></code></a>
                        | <a class="reference internal" href="#grammar-token-inductive"><code class="xref docutils literal notranslate"><span class="pre">inductive</span></code></a>
                        | <a class="reference internal" href="#grammar-token-fixpoint"><code class="xref docutils literal notranslate"><span class="pre">fixpoint</span></code></a>
                        | <a class="reference internal" href="#grammar-token-assertion"><code class="xref docutils literal notranslate"><span class="pre">assertion</span></code></a> <a class="reference internal" href="#grammar-token-proof"><code class="xref docutils literal notranslate"><span class="pre">proof</span></code></a>
<strong id="grammar-token-assumption">assumption        </strong> ::=  <a class="reference internal" href="#grammar-token-assumption-keyword"><code class="xref docutils literal notranslate"><span class="pre">assumption_keyword</span></code></a> <a class="reference internal" href="#grammar-token-assums"><code class="xref docutils literal notranslate"><span class="pre">assums</span></code></a>.
<strong id="grammar-token-assumption-keyword">assumption_keyword</strong> ::=  Axiom | Conjecture
                        | Parameter | Parameters
                        | Variable | Variables
                        | Hypothesis | Hypotheses
<strong id="grammar-token-assums">assums            </strong> ::=  <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> … <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> : <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                        | ( <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> … <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> : <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> ) … ( <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> … <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> : <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> )
<strong id="grammar-token-definition">definition        </strong> ::=  [Local] Definition <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> [<a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a>] [: <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>] := <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> .
                        | Let <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> [<a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a>] [: <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>] := <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> .
<strong id="grammar-token-inductive">inductive         </strong> ::=  Inductive <a class="reference internal" href="#grammar-token-ind-body"><code class="xref docutils literal notranslate"><span class="pre">ind_body</span></code></a> with … with <a class="reference internal" href="#grammar-token-ind-body"><code class="xref docutils literal notranslate"><span class="pre">ind_body</span></code></a> .
                        | CoInductive <a class="reference internal" href="#grammar-token-ind-body"><code class="xref docutils literal notranslate"><span class="pre">ind_body</span></code></a> with … with <a class="reference internal" href="#grammar-token-ind-body"><code class="xref docutils literal notranslate"><span class="pre">ind_body</span></code></a> .
<strong id="grammar-token-ind-body">ind_body          </strong> ::=  <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> [<a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a>] : <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> :=
                        [[|] <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> [<a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a>] [:<a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>] | … | <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> [<a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a>] [:<a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>]]
<strong id="grammar-token-fixpoint">fixpoint          </strong> ::=  Fixpoint <a class="reference internal" href="#grammar-token-fix-body"><code class="xref docutils literal notranslate"><span class="pre">fix_body</span></code></a> with … with <a class="reference internal" href="#grammar-token-fix-body"><code class="xref docutils literal notranslate"><span class="pre">fix_body</span></code></a> .
                        | CoFixpoint <a class="reference internal" href="#grammar-token-cofix-body"><code class="xref docutils literal notranslate"><span class="pre">cofix_body</span></code></a> with … with <a class="reference internal" href="#grammar-token-cofix-body"><code class="xref docutils literal notranslate"><span class="pre">cofix_body</span></code></a> .
<strong id="grammar-token-assertion">assertion         </strong> ::=  <a class="reference internal" href="#grammar-token-assertion-keyword"><code class="xref docutils literal notranslate"><span class="pre">assertion_keyword</span></code></a> <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> [<a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a>] : <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> .
<strong id="grammar-token-assertion-keyword">assertion_keyword </strong> ::=  Theorem | Lemma
                        | Remark | Fact
                        | Corollary | Proposition
                        | Definition | Example
<strong id="grammar-token-proof">proof             </strong> ::=  Proof . … Qed .
                        | Proof . … Defined .
                        | Proof . … Admitted .
</pre>
<p>This grammar describes <em>The Vernacular</em> which is the language of
commands of Gallina. A sentence of the vernacular language, like in
many natural languages, begins with a capital letter and ends with a
dot.</p>
<p>The different kinds of command are described hereafter. They all suppose
that the terms occurring in the sentences are well-typed.</p>
<div class="section" id="assumptions">
<span id="gallina-assumptions"></span><h3>Assumptions<a class="headerlink" href="#assumptions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Assumptions extend the environment with axioms, parameters, hypotheses
or variables. An assumption binds an <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> to a <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>. It is accepted
by Coq if and only if this <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> is a correct type in the environment
preexisting the declaration and if <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> was not previously defined in
the same module. This <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> is considered to be the type (or
specification, or statement) assumed by <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> and we say that <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>
has type <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>.</p>
<span class="target" id="axiom"></span><dl class="cmd">
<dt id="coq:cmd.parameter">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Parameter</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmd.parameter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command links <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> to the name <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> as its specification in
the global context. The fact asserted by <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> is thus assumed as a
postulate.</p>
<dl class="exn">
<dt id="coq:exn.ident-already-exists-axiom">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>already</span> <span>exists.</span></span></code><a class="headerlink" href="#coq:exn.ident-already-exists-axiom" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Parameter</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code></dt>
<dd><p>Adds several parameters with specification <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Parameter </span><span class="repeat-wrapper"><span class="repeat"><span>( </span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Adds blocks of parameters with different specifications.</p>
</dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.local-parameter">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Local</span> <span>Parameter</span> <span class="repeat-wrapper"><span class="repeat"><span>( </span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.local-parameter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Such parameters are never made accessible through their unqualified name by
<a class="reference internal" href="gallina-extensions.html#coq:cmd.import" title="Import"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Import</span></code></a> and its variants. You have to explicitly give their fully
qualified name to refer to them.</p>
</dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.parameters">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>Local</span></span><span class="notation-sup">?</span></span> <span>Parameters</span> <span class="repeat-wrapper"><span class="repeat"><span>( </span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.parameters" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:cmdv.axiom">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>Local</span></span><span class="notation-sup">?</span></span> <span>Axiom</span> <span class="repeat-wrapper"><span class="repeat"><span>( </span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.axiom" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:cmdv.axioms">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>Local</span></span><span class="notation-sup">?</span></span> <span>Axioms</span> <span class="repeat-wrapper"><span class="repeat"><span>( </span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.axioms" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:cmdv.conjecture">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>Local</span></span><span class="notation-sup">?</span></span> <span>Conjecture</span> <span class="repeat-wrapper"><span class="repeat"><span>( </span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.conjecture" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:cmdv.conjectures">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>Local</span></span><span class="notation-sup">?</span></span> <span>Conjectures</span> <span class="repeat-wrapper"><span class="repeat"><span>( </span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.conjectures" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>These variants are synonyms of <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span class="pre">Local</span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <span><span class="pre">Parameter</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">( </span></span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a> <span><span class="pre">)</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.variable">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Variable</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmd.variable" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command links <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> to the name <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> in the context of
the current section (see Section <a class="reference internal" href="gallina-extensions.html#section-mechanism"><span class="std std-ref">セクション機構</span></a> for a description of
the section mechanism). When the current section is closed, name <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>
will be unknown and every object using this variable will be explicitly
parametrized (the variable is <em>discharged</em>). Using the <a class="reference internal" href="#coq:cmd.variable" title="Variable"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Variable</span></code></a> command out
of any section is equivalent to using <a class="reference internal" href="#coq:cmdv.local-parameter" title="Local Parameter"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Local</span> <span class="pre">Parameter</span></code></a>.</p>
<dl class="exn">
<dt id="coq:exn.ident-already-exists-variable">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>already</span> <span>exists.</span></span></code><a class="headerlink" href="#coq:exn.ident-already-exists-variable" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Variable</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>Links <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> to each <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Variable </span><span class="repeat-wrapper"><span class="repeat"><span>( </span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Adds blocks of variables with different specifications.</p>
</dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.variables">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Variables </span><span class="repeat-wrapper"><span class="repeat"><span>( </span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a><span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.variables" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:cmdv.hypothesis">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Hypothesis </span><span class="repeat-wrapper"><span class="repeat"><span>( </span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a><span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.hypothesis" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:cmdv.hypotheses">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Hypotheses </span><span class="repeat-wrapper"><span class="repeat"><span>( </span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a><span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.hypotheses" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>These variants are synonyms of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">Variable </span></span><span class="repeat-wrapper"><span class="repeat"><span><span class="pre">( </span></span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">:</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">)</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>.</p>
</dd></dl>

</dd></dl>

<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>It is advised to use the commands <a class="reference internal" href="#coq:cmdv.axiom" title="Axiom"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Axiom</span></code></a>, <a class="reference internal" href="#coq:cmdv.conjecture" title="Conjecture"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Conjecture</span></code></a> and
<a class="reference internal" href="#coq:cmdv.hypothesis" title="Hypothesis"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Hypothesis</span></code></a> (and their plural forms) for logical postulates (i.e. when
the assertion <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> is of sort <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>), and to use the commands
<a class="reference internal" href="#coq:cmd.parameter" title="Parameter"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Parameter</span></code></a> and <a class="reference internal" href="#coq:cmd.variable" title="Variable"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Variable</span></code></a> (and their plural forms) in other cases
(corresponding to the declaration of an abstract mathematical entity).</p>
</div>
</div>
<div class="section" id="definitions">
<span id="gallina-definitions"></span><h3>Definitions<a class="headerlink" href="#definitions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Definitions extend the environment with associations of names to terms.
A definition can be seen as a way to give a meaning to a name or as a
way to abbreviate a term. In any case, the name can later be replaced at
any time by its definition.</p>
<p>The operation of unfolding a name into its definition is called
<span class="math notranslate nohighlight">\(\delta\)</span>-conversion (see Section <a class="reference internal" href="cic.html#delta-reduction"><span class="std std-ref">δ-reduction</span></a>). A
definition is accepted by the system if and only if the defined term is
well-typed in the current context of the definition and if the name is
not already used. The name defined by the definition is called a
<em>constant</em> and the term it refers to is its <em>body</em>. A definition has a
type which is the type of its body.</p>
<p>A formal presentation of constants and environments is given in
Section <a class="reference internal" href="cic.html#typing-rules"><span class="std std-ref">Typing rules</span></a>.</p>
<dl class="cmd">
<dt id="coq:cmd.definition">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Definition</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:=</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:cmd.definition" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command binds <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> to the name <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> in the environment,
provided that <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> is well-typed.</p>
<dl class="exn">
<dt id="coq:exn.ident-already-exists-definition">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>already</span> <span>exists.</span></span></code><a class="headerlink" href="#coq:exn.ident-already-exists-definition" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Definition</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>:=</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>This variant checks that the type of <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> is definitionally equal to
<a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>, and registers <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> as being of type
<a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>, and bound to value <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.</p>
<dl class="exn">
<dt id="coq:exn.the-term-term-has-type-type-while-it-is-expected-to-have-type-type">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>The</span> <span>term</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span>has</span> <span>type</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>while</span> <span>it</span> <span>is</span> <span>expected</span> <span>to</span> <span>have</span> <span>type</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a><span>'.</span></span></code><a class="headerlink" href="#coq:exn.the-term-term-has-type-type-while-it-is-expected-to-have-type-type" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Definition</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>This is equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">Definition</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre"> : forall</span></span> <a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a><span><span class="pre">,</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre"> := fun</span></span> <a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a><span><span class="pre"> =&gt; </span></span><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
</dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.local-definition">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Local</span> <span>Definition</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:cmdv.local-definition" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Such definitions are never made accessible through their
unqualified name by <a class="reference internal" href="gallina-extensions.html#coq:cmd.import" title="Import"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Import</span></code></a> and its variants.
You have to explicitly give their fully qualified name to refer to them.</p>
</dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.example">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>Local</span></span><span class="notation-sup">?</span></span> <span>Example</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:cmdv.example" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This is equivalent to <a class="reference internal" href="#coq:cmd.definition" title="Definition"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Definition</span></code></a>.</p>
</dd></dl>

</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">参考</p>
<p><a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.opaque" title="Opaque"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Opaque</span></code></a>, <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.transparent" title="Transparent"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Transparent</span></code></a>, <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.unfold" title="unfold"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">unfold</span></code></a>.</p>
</div>
<dl class="cmd">
<dt id="coq:cmd.let">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Let</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:=</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:cmd.let" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command binds the value <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> to the name <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> in the
environment of the current section. The name <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> disappears when the
current section is eventually closed, and all persistent objects (such
as theorems) defined within the section and depending on <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> are
prefixed by the let-in definition <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">let</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre"> := </span></span><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">in</span></span></span></code>.
Using the <a class="reference internal" href="#coq:cmd.let" title="Let"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Let</span></code></a> command out of any section is equivalent to using
<a class="reference internal" href="#coq:cmdv.local-definition" title="Local Definition"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Local</span> <span class="pre">Definition</span></code></a>.</p>
<dl class="exn">
<dt id="coq:exn.ident-already-exists-let">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>already</span> <span>exists.</span></span></code><a class="headerlink" href="#coq:exn.ident-already-exists-let" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Let</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.let-fixpoint">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Let</span> <span>Fixpoint</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-fix-body"><span class="hole">fix_body</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-fix-body"><span class="hole">fix_body</span></a></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:cmdv.let-fixpoint" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.let-cofixpoint">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Let</span> <span>CoFixpoint</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-cofix-body"><span class="hole">cofix_body</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-cofix-body"><span class="hole">cofix_body</span></a></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:cmdv.let-cofixpoint" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">参考</p>
<p>Section <a class="reference internal" href="gallina-extensions.html#section-mechanism"><span class="std std-ref">セクション機構</span></a>, commands <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.opaque" title="Opaque"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Opaque</span></code></a>,
<a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.transparent" title="Transparent"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Transparent</span></code></a>, and tactic <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.unfold" title="unfold"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">unfold</span></code></a>.</p>
</div>
</div>
<div class="section" id="inductive-definitions">
<span id="gallina-inductive-definitions"></span><h3>Inductive definitions<a class="headerlink" href="#inductive-definitions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>We gradually explain simple inductive types, simple annotated inductive
types, simple parametric inductive types, mutually inductive types. We
explain also co-inductive types.</p>
<div class="section" id="simple-inductive-types">
<h4>Simple inductive types<a class="headerlink" href="#simple-inductive-types" title="このヘッドラインへのパーマリンク">¶</a></h4>
<dl class="cmd">
<dt id="coq:cmd.inductive">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Inductive</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-sort"><span class="hole">sort</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat"><span>|</span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat"><span>|</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:cmd.inductive" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command defines a simple inductive type and its constructors.
The first <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is the name of the inductively defined type
and <a class="reference internal" href="#grammar-token-sort"><code class="xref std std-token docutils literal notranslate"><span class="pre">sort</span></code></a> is the universe where it lives. The next <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>s
are the names of its constructors and <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> their respective types.
Depending on the universe where the inductive type <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> lives
(e.g. its type <a class="reference internal" href="#grammar-token-sort"><code class="xref std std-token docutils literal notranslate"><span class="pre">sort</span></code></a>), Coq provides a number of destructors.
Destructors are named <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><code class="docutils literal notranslate"><span class="pre">_ind</span></code>, <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><code class="docutils literal notranslate"><span class="pre">_rec</span></code>
or <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><code class="docutils literal notranslate"><span class="pre">_rect</span></code> which respectively correspond to elimination
principles on <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Set</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Type</span></span></code>.
The type of the destructors expresses structural induction/recursion
principles over objects of type <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>.
The constant <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><code class="docutils literal notranslate"><span class="pre">_ind</span></code> is always provided,
whereas <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><code class="docutils literal notranslate"><span class="pre">_rec</span></code> and <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><code class="docutils literal notranslate"><span class="pre">_rect</span></code> can be
impossible to derive (for example, when <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is a proposition).</p>
<dl class="exn">
<dt id="coq:exn.non-strictly-positive-occurrence-of-ident-in-type">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Non</span> <span>strictly</span> <span>positive</span> <span>occurrence</span> <span>of</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>in</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a><span>.</span></span></code><a class="headerlink" href="#coq:exn.non-strictly-positive-occurrence-of-ident-in-type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The types of the constructors have to satisfy a <em>positivity condition</em>
(see Section <a class="reference internal" href="cic.html#positivity"><span class="std std-ref">Positivity Condition</span></a>). This condition ensures the soundness of
the inductive definition.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.the-conclusion-of-type-is-not-valid-it-must-be-built-from-ident">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>The</span> <span>conclusion</span> <span>of</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>is</span> <span>not</span> <span>valid;</span> <span>it</span> <span>must</span> <span>be</span> <span>built</span> <span>from</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a><span>.</span></span></code><a class="headerlink" href="#coq:exn.the-conclusion-of-type-is-not-valid-it-must-be-built-from-ident" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The conclusion of the type of the constructors must be the inductive type
<a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> being defined (or <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> applied to arguments in
the case of annotated inductive types — cf. next section).</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<p>The set of natural numbers is defined as:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">nat</span><span> : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">O</span><span> : </span><span class="coqdoc-var">nat</span><span>
| </span><span class="coqdoc-var">S</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span>.</span></dt><dd><span>nat is defined
nat_rect is defined
nat_ind is defined
nat_rec is defined</span></dd>
</dl>
</div>
<p>The type nat is defined as the least <code class="code Coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Set</span></span></code> containing <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code> and closed by
the <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">S</span></span></code> constructor. The names <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">S</span></span></code> are added to the
environment.</p>
<p>Now let us have a look at the elimination principles. They are three of them:
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_ind</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_rec</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_rect</span></span></code>. The type of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_ind</span></span></code> is:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">nat_ind</span><span>.</span></dt><dd><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat_ind</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> P : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,
       </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">O</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">))</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
</dl>
</div>
<p>This is the well known structural induction principle over natural
numbers, i.e. the second-order form of Peano’s induction principle. It
allows proving some universal property of natural numbers (<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span>
<span class="name"><span class="pre">n</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">nat</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">n</span></span></code>) by induction on <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code>.</p>
<p>The types of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_rec</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_rect</span></span></code> are similar, except that they pertain
to <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">P</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">nat</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="keyword namespace"><span class="pre">Set</span></span><span class="operator"><span class="pre">)</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">P</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">nat</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="keyword type"><span class="pre">Type</span></span><span class="operator"><span class="pre">)</span></span></code> respectively. They correspond to
primitive induction principles (allowing dependent types) respectively
over sorts <code class="docutils literal notranslate"><span class="pre">Set</span></code> and <code class="docutils literal notranslate"><span class="pre">Type</span></code>.</p>
</div>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Inductive</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-sort"><span class="hole">sort</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat"><span>|</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span></span></code></dt>
<dd><p>Constructors <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>s can come with <a class="reference internal" href="#grammar-token-binders"><code class="xref std std-token docutils literal notranslate"><span class="pre">binders</span></code></a> in which case,
the actual type of the constructor is <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">forall</span></span> <a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a><span><span class="pre">,</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code>.</p>
<p>In the case where inductive types have no annotations (next section
gives an example of such annotations), a constructor can be defined
by only giving the type of its arguments.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">nat</span><span> : </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-var">O</span><span> | </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">_</span><span>:</span><span class="coqdoc-var">nat</span><span>).</span></dt><dd class="coqtop-hidden"><span>Toplevel input, characters 0-37:
&gt; Inductive nat : Set := O | S (_:nat).
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> nat already exists.</span></dd>
</dl>
</div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="simple-annotated-inductive-types">
<h4>Simple annotated inductive types<a class="headerlink" href="#simple-annotated-inductive-types" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>In an annotated inductive types, the universe where the inductive type
is defined is no longer a simple sort, but what is called an arity,
which is a type whose conclusion is a sort.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>As an example of annotated inductive types, let us define the
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even</span></span></code> predicate:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">even</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
| </span><span class="coqdoc-var">even_0</span><span> : </span><span class="coqdoc-var">even</span><span> </span><span class="coqdoc-var">O</span><span>
| </span><span class="coqdoc-var">even_SS</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">even</span><span> </span><span class="coqdoc-var">n</span><span> -&gt; </span><span class="coqdoc-var">even</span><span> (</span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>)).</span></dt><dd><span>even is defined
even_ind is defined</span></dd>
</dl>
</div>
<p>The type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="keyword type"><span class="pre">Prop</span></span></code> means that even is a unary predicate (inductively
defined) over natural numbers. The type of its two constructors are the
defining clauses of the predicate even. The type of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even_ind</span></span></code> is:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">even_ind</span><span>.</span></dt><dd><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">even_ind</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> P : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,
       </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">O</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
       (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">even</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)))</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
       </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">even</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
</dl>
</div>
<p>From a mathematical point of view it asserts that the natural numbers satisfying
the predicate even are exactly in the smallest set of naturals satisfying the
clauses <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even_0</span></span></code> or <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even_SS</span></span></code>. This is why, when we want to prove any
predicate <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> over elements of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even</span></span></code>, it is enough to prove it for <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code>
and to prove that if any natural number <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> satisfies <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> its double
successor <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">n</span></span><span class="operator"><span class="pre">))</span></span></code> satisfies also <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code>. This is indeed analogous to the
structural induction principle we got for <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat</span></span></code>.</p>
</div>
</div>
<div class="section" id="parametrized-inductive-types">
<h4>Parametrized inductive types<a class="headerlink" href="#parametrized-inductive-types" title="このヘッドラインへのパーマリンク">¶</a></h4>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Inductive</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat"><span>|</span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat"><span>|</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>In the previous example, each constructor introduces a different
instance of the predicate <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even</span></span></code>. In some cases, all the constructors
introduce the same generic instance of the inductive definition, in
which case, instead of an annotation, we use a context of parameters
which are <a class="reference internal" href="#grammar-token-binders"><code class="xref std std-token docutils literal notranslate"><span class="pre">binders</span></code></a> shared by all the constructors of the definition.</p>
<p>Parameters differ from inductive type annotations in the fact that the
conclusion of each type of constructor invoke the inductive type with
the same values of parameters as its specification.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>A typical example is the definition of polymorphic lists:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">nil</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>
| </span><span class="coqdoc-var">cons</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>.</span></dt><dd class="coqtop-hidden"><span>list is defined
list_rect is defined
list_ind is defined
list_rec is defined</span></dd>
</dl>
</div>
<p>In the type of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nil</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">cons</span></span></code>, we write <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">list</span></span> <span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">)</span></span></code> and not
just <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">list</span></span></code>. The constructors <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nil</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">cons</span></span></code> will have respectively
types:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">nil</span><span>.</span></dt><dd><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">cons</span><span>.</span></dt><dd><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
</dl>
</div>
<p>Types of destructors are also quantified with <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword namespace"><span class="pre">Set</span></span><span class="operator"><span class="pre">)</span></span></code>.</p>
<p>Once again, it is possible to specify only the type of the arguments
of the constructors, and to omit the type of the conclusion:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-var">nil</span><span> | </span><span class="coqdoc-var">cons</span><span> (</span><span class="coqdoc-var">_</span><span>:</span><span class="coqdoc-var">A</span><span>) (</span><span class="coqdoc-var">_</span><span>:</span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>).</span></dt><dd class="coqtop-hidden"><span>Toplevel input, characters 0-60:
&gt; Inductive list (A:Set) : Set := nil | cons (_:A) (_:list A).
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> list already exists.</span></dd>
</dl>
</div>
</div>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">注釈</p>
<ul>
<li><p>It is possible in the type of a constructor, to
invoke recursively the inductive definition on an argument which is not
the parameter itself.</p>
<p>One can define :</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list2</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">nil2</span><span> : </span><span class="coqdoc-var">list2</span><span> </span><span class="coqdoc-var">A</span><span>
| </span><span class="coqdoc-var">cons2</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list2</span><span> (</span><span class="coqdoc-var">A</span><span>*</span><span class="coqdoc-var">A</span><span>) -&gt; </span><span class="coqdoc-var">list2</span><span> </span><span class="coqdoc-var">A</span><span>.</span></dt><dd><span>list2 is defined
list2_rect is defined
list2_ind is defined
list2_rec is defined</span></dd>
</dl>
</div>
<p>that can also be written by specifying only the type of the arguments:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list2</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-var">nil2</span><span> | </span><span class="coqdoc-var">cons2</span><span> (</span><span class="coqdoc-var">_</span><span>:</span><span class="coqdoc-var">A</span><span>) (</span><span class="coqdoc-var">_</span><span>:</span><span class="coqdoc-var">list2</span><span> (</span><span class="coqdoc-var">A</span><span>*</span><span class="coqdoc-var">A</span><span>)).</span></dt><dd><span>list2 is defined
list2_rect is defined
list2_ind is defined
list2_rec is defined</span></dd>
</dl>
</div>
<p>But the following definition will give an error:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">listw</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">nilw</span><span> : </span><span class="coqdoc-var">listw</span><span> (</span><span class="coqdoc-var">A</span><span>*</span><span class="coqdoc-var">A</span><span>)</span><span>
| </span><span class="coqdoc-var">consw</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">listw</span><span> (</span><span class="coqdoc-var">A</span><span>*</span><span class="coqdoc-var">A</span><span>) -&gt; </span><span class="coqdoc-var">listw</span><span> (</span><span class="coqdoc-var">A</span><span>*</span><span class="coqdoc-var">A</span><span>).</span></dt><dd><span>The command has indeed failed with message:
Last occurrence of &quot;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">listw</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&quot; must have &quot;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&quot; as 1st argument in
 &quot;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">listw</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)%type&quot;.</span></dd>
</dl>
</div>
<p>because the conclusion of the type of constructors should be <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">listw</span></span> <span class="name"><span class="pre">A</span></span></code>
in both cases.</p>
</li>
<li><p>A parametrized inductive definition can be defined using annotations
instead of parameters but it will sometimes give a different (bigger)
sort for the inductive definition and will produce a less convenient
rule for case elimination.</p></li>
</ul>
</div>
<div class="admonition seealso">
<p class="admonition-title">参考</p>
<p>Section <a class="reference internal" href="cic.html#inductive-definitions"><span class="std std-ref">Inductive Definitions</span></a> and the <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a> tactic.</p>
</div>
</div>
<div class="section" id="variants">
<h4>Variants<a class="headerlink" href="#variants" title="このヘッドラインへのパーマリンク">¶</a></h4>
<dl class="cmd">
<dt id="coq:cmd.variant">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Variant</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat"><span>|</span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat"><span>|</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:cmd.variant" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The <a class="reference internal" href="#coq:cmd.variant" title="Variant"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Variant</span></code></a> command is identical to the <a class="reference internal" href="#coq:cmd.inductive" title="Inductive"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Inductive</span></code></a> command, except
that it disallows recursive definition of types (for instance, lists cannot
be defined using <a class="reference internal" href="#coq:cmd.variant" title="Variant"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Variant</span></code></a>). No induction scheme is generated for
this variant, unless option <a class="reference internal" href="../user-extensions/proof-schemes.html#coq:flag.nonrecursive-elimination-schemes" title="Nonrecursive Elimination Schemes"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Nonrecursive</span> <span class="pre">Elimination</span> <span class="pre">Schemes</span></code></a> is on.</p>
<dl class="exn">
<dt id="coq:exn.the-num-th-argument-of-ident-must-be-ident-in-type">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>The</span> <a class="reference internal" href="#grammar-token-num"><span class="hole">num</span></a> <span>th</span> <span>argument</span> <span>of</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>must</span> <span>be</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>in</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a><span>.</span></span></code><a class="headerlink" href="#coq:exn.the-num-th-argument-of-ident-must-be-ident-in-type" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="mutually-defined-inductive-types">
<h4>Mutually defined inductive types<a class="headerlink" href="#mutually-defined-inductive-types" title="このヘッドラインへのパーマリンク">¶</a></h4>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Inductive</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat"><span>|</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="repeat-wrapper"><span class="repeat"><span>|</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>This variant allows defining a block of mutually inductive types.
It has the same semantics as the above <a class="reference internal" href="#coq:cmd.inductive" title="Inductive"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Inductive</span></code></a> definition for each
<a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>. All <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> are simultaneously added to the environment.
Then well-typing of constructors can be checked. Each one of the <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>
can be used on its own.</p>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Inductive</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat"><span>|</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="repeat-wrapper"><span class="repeat"><span>|</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>In this variant, the inductive definitions are parametrized
with <a class="reference internal" href="#grammar-token-binders"><code class="xref std std-token docutils literal notranslate"><span class="pre">binders</span></code></a>. However, parameters correspond to a local context
in which the whole set of inductive declarations is done. For this
reason, the parameters must be strictly the same for each inductive types.</p>
</dd></dl>

</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<p>The typical example of a mutual inductive data type is the one for trees and
forests. We assume given two types <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code> as variables. It can
be declared the following way.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Variables</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> : </span><span class="coqdoc-keyword">Set</span><span>.</span></dt><dd class="coqtop-hidden"><span>Toplevel input, characters 0-20:
&gt; Variables A B : Set.
&gt; ^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-yellow ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Warning:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> A is declared as a local axiom [local-declaration,scope]
A is declared
Toplevel input, characters 0-20:
&gt; Variables A B : Set.
&gt; ^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-yellow ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Warning:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> B is declared as a local axiom [local-declaration,scope]
B is declared</span></dd>
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">tree</span><span> : </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-var">node</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> -&gt; </span><span class="coqdoc-var">tree</span><span>
</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">forest</span><span> : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">leaf</span><span> : </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span>
| </span><span class="coqdoc-var">cons</span><span> : </span><span class="coqdoc-var">tree</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span>.</span></dt><dd class="coqtop-hidden"><span>tree, forest are defined
tree_rect is defined
tree_ind is defined
tree_rec is defined
forest_rect is defined
forest_ind is defined
forest_rec is defined</span></dd>
</dl>
</div>
<p>This declaration generates automatically six induction principles. They are
respectively called <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">tree_rec</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">tree_ind</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">tree_rect</span></span></code>,
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">forest_rec</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">forest_ind</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">forest_rect</span></span></code>. These ones are not the most
general ones but are just the induction principles corresponding to each
inductive part seen as a single inductive definition.</p>
<p>To illustrate this point on our example, we give the types of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">tree_rec</span></span></code>
and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">forest_rec</span></span></code>.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">tree_rec</span><span>.</span></dt><dd><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">tree_rec</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> P : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">tree</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,
       (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (a : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (f : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">forest</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">), </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">node</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">))</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> t : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">tree</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">forest_rec</span><span>.</span></dt><dd><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">forest_rec</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> P : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">forest</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,
       (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">B</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">leaf</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">))</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
       (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (t : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">tree</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (f0 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">forest</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">), </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">))</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
       </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> f1 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">forest</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
</dl>
</div>
<p>Assume we want to parametrize our mutual inductive definitions with the
two type variables <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code>, the declaration should be
done the following way:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">tree</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-var">node</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">tree</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>
</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">forest</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">leaf</span><span> : </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>
| </span><span class="coqdoc-var">cons</span><span> : </span><span class="coqdoc-var">tree</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>.</span></dt><dd class="coqtop-hidden"><span>Toplevel input, characters 0-171:
&gt; Inductive tree (A B:Set) : Set := node : A -&gt; forest A B -&gt; tree A B with forest (A B:Set) : Set := | leaf : B -&gt; forest A B | cons : tree A B -&gt; forest A B -&gt; forest A B.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> forest already exists.</span></dd>
</dl>
</div>
<p>Assume we define an inductive definition inside a section
(cf. <a class="reference internal" href="gallina-extensions.html#section-mechanism"><span class="std std-ref">セクション機構</span></a>). When the section is closed, the variables
declared in the section and occurring free in the declaration are added as
parameters to the inductive definition.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参考</p>
<p>A generic command <a class="reference internal" href="../user-extensions/proof-schemes.html#coq:cmd.scheme" title="Scheme"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Scheme</span></code></a> is useful to build automatically various
mutual induction principles.</p>
</div>
</div>
<div class="section" id="co-inductive-types">
<span id="coinductive-types"></span><h4>Co-inductive types<a class="headerlink" href="#co-inductive-types" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The objects of an inductive type are well-founded with respect to the
constructors of the type. In other words, such objects contain only a
<em>finite</em> number of constructors. Co-inductive types arise from relaxing
this condition, and admitting types whose objects contain an infinity of
constructors. Infinite objects are introduced by a non-ending (but
effective) process of construction, defined in terms of the constructors
of the type.</p>
<dl class="cmd">
<dt id="coq:cmd.coinductive">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>CoInductive</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat"><span>|</span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat"><span>|</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:cmd.coinductive" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command introduces a co-inductive type.
The syntax of the command is the same as the command <a class="reference internal" href="#coq:cmd.inductive" title="Inductive"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Inductive</span></code></a>.
No principle of induction is derived from the definition of a co-inductive
type, since such principles only make sense for inductive types.
For co-inductive types, the only elimination principle is case analysis.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<p>An example of a co-inductive type is the type of infinite sequences of
natural numbers, usually called streams.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">CoInductive</span><span> </span><span class="coqdoc-var">Stream</span><span> : </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-var">Seq</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">Stream</span><span> -&gt; </span><span class="coqdoc-var">Stream</span><span>.</span></dt><dd class="coqtop-hidden"><span>Stream is defined</span></dd>
</dl>
</div>
<p>The usual destructors on streams <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">hd</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">Stream</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="name"><span class="pre">nat</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">tl</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">Str</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="name"><span class="pre">Str</span></span></code>
can be defined as follows:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">hd</span><span> (</span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">Stream</span><span>) := </span><span class="coqdoc-keyword">let</span><span> (</span><span class="coqdoc-var">a</span><span>,</span><span class="coqdoc-var">s</span><span>) := </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">a</span><span>.</span></dt><dd class="coqtop-hidden"><span>hd is defined</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">tl</span><span> (</span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">Stream</span><span>) := </span><span class="coqdoc-keyword">let</span><span> (</span><span class="coqdoc-var">a</span><span>,</span><span class="coqdoc-var">s</span><span>) := </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">s</span><span>.</span></dt><dd class="coqtop-hidden"><span>tl is defined</span></dd>
</dl>
</div>
</div>
<p>Definition of co-inductive predicates and blocks of mutually
co-inductive definitions are also allowed.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>An example of a co-inductive predicate is the extensional equality on
streams:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">CoInductive</span><span> </span><span class="coqdoc-var">EqSt</span><span> : </span><span class="coqdoc-var">Stream</span><span> -&gt; </span><span class="coqdoc-var">Stream</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
  </span><span class="coqdoc-var">eqst</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">s1</span><span> </span><span class="coqdoc-var">s2</span><span>:</span><span class="coqdoc-var">Stream</span><span>,</span><span>
           </span><span class="coqdoc-var">hd</span><span> </span><span class="coqdoc-var">s1</span><span> = </span><span class="coqdoc-var">hd</span><span> </span><span class="coqdoc-var">s2</span><span> -&gt; </span><span class="coqdoc-var">EqSt</span><span> (</span><span class="coqdoc-var">tl</span><span> </span><span class="coqdoc-var">s1</span><span>) (</span><span class="coqdoc-var">tl</span><span> </span><span class="coqdoc-var">s2</span><span>) -&gt; </span><span class="coqdoc-var">EqSt</span><span> </span><span class="coqdoc-var">s1</span><span> </span><span class="coqdoc-var">s2</span><span>.</span></dt><dd class="coqtop-hidden"><span>EqSt is defined</span></dd>
</dl>
</div>
<p>In order to prove the extensional equality of two streams <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">s1</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">s2</span></span></code>
we have to construct an infinite proof of equality, that is, an infinite
object of type <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">EqSt</span></span> <span class="name"><span class="pre">s1</span></span> <span class="name"><span class="pre">s2</span></span><span class="operator"><span class="pre">)</span></span></code>. We will see how to introduce infinite
objects in Section <a class="reference internal" href="#cofixpoint"><span class="std std-ref">Definitions of recursive objects in co-inductive types</span></a>.</p>
</div>
</div>
</div>
<div class="section" id="definition-of-recursive-functions">
<h3>Definition of recursive functions<a class="headerlink" href="#definition-of-recursive-functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="section" id="definition-of-functions-by-recursion-over-inductive-objects">
<h4>Definition of functions by recursion over inductive objects<a class="headerlink" href="#definition-of-functions-by-recursion-over-inductive-objects" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>This section describes the primitive form of definition by recursion over
inductive objects. See the <a class="reference internal" href="gallina-extensions.html#coq:cmd.function" title="Function"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Function</span></code></a> command for more advanced
constructions.</p>
<span class="target" id="fixpoint"></span><dl class="cmd">
<dt id="coq:cmd.fixpoint">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Fixpoint</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span class="curlies">{<span>struct</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a>}</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:cmd.fixpoint" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command allows defining functions by pattern matching over inductive
objects using a fixed point construction. The meaning of this declaration is
to define <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> a recursive function with arguments specified by
the <a class="reference internal" href="#grammar-token-binders"><code class="xref std std-token docutils literal notranslate"><span class="pre">binders</span></code></a> such that <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> applied to arguments
corresponding to these <a class="reference internal" href="#grammar-token-binders"><code class="xref std std-token docutils literal notranslate"><span class="pre">binders</span></code></a> has type <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>, and is
equivalent to the expression <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>. The type of <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is
consequently <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">forall</span></span> <a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a><span><span class="pre">,</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> and its value is equivalent
to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">fun</span></span> <a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a> <span><span class="pre">=&gt;</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
<p>To be accepted, a <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> definition has to satisfy some syntactical
constraints on a special argument called the decreasing argument. They
are needed to ensure that the <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> definition always terminates.
The point of the <code class="docutils literal notranslate"><span class="notation"><span class="curlies"><span class="pre">{</span><span><span class="pre">struct</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span class="pre">}</span></span></span></code> annotation is to let the user tell the
system which argument decreases along the recursive calls.</p>
<p>The <code class="docutils literal notranslate"><span class="notation"><span class="curlies"><span class="pre">{</span><span><span class="pre">struct</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span class="pre">}</span></span></span></code> annotation may be left implicit, in this case the
system tries successively arguments from left to right until it finds one
that satisfies the decreasing condition.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<ul class="simple">
<li><p>Some fixpoints may have several arguments that fit as decreasing
arguments, and this choice influences the reduction of the fixpoint.
Hence an explicit annotation must be used if the leftmost decreasing
argument is not the desired one. Writing explicit annotations can also
speed up type checking of large mutual fixpoints.</p></li>
<li><p>In order to keep the strong normalization property, the fixed point
reduction will only be performed when the argument in position of the
decreasing argument (which type should be in an inductive definition)
starts with a constructor.</p></li>
</ul>
</div>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>One can define the addition function as :</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">add</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">n</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">m</span><span>
| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">add</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">m</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt><dd><span>add is defined
add is recursively defined (decreasing on 1st argument)</span></dd>
</dl>
</div>
<p>The match operator matches a value (here <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code>) with the various
constructors of its (inductive) type. The remaining arguments give the
respective values to be returned, as functions of the parameters of the
corresponding constructor. Thus here when <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> equals <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code> we return
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">m</span></span></code>, and when <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> equals <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">p</span></span><span class="operator"><span class="pre">)</span></span></code> we return <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">add</span></span> <span class="name"><span class="pre">p</span></span> <span class="name"><span class="pre">m</span></span><span class="operator"><span class="pre">))</span></span></code>.</p>
<p>The match operator is formally described in
Section <a class="reference internal" href="cic.html#match-construction"><span class="std std-ref">The match ... with ... end construction</span></a>.
The system recognizes that in the inductive call <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">add</span></span> <span class="name"><span class="pre">p</span></span> <span class="name"><span class="pre">m</span></span><span class="operator"><span class="pre">)</span></span></code> the first
argument actually decreases because it is a <em>pattern variable</em> coming
from <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span> <span class="name"><span class="pre">n</span></span> <span class="keyword"><span class="pre">with</span></span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>The following definition is not correct and generates an error message:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">wrongplus</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">n</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">n</span><span>
| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">wrongplus</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">p</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt><dd><span>The command has indeed failed with message:
Recursive definition of wrongplus is ill-formed.
In environment
wrongplus : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
p : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
Recursive call to wrongplus has principal argument equal to 
&quot;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&quot; instead of a subterm of &quot;n&quot;.
Recursive definition is:
&quot;</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">match</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">with</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
                  | 0 =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
                  | </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">wrongplus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)
                  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">end</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&quot;.</span></dd>
</dl>
</div>
<p>because the declared decreasing argument <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> does not actually
decrease in the recursive call. The function computing the addition over
the second argument should rather be written:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">plus</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">m</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">n</span><span>
| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">p</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt><dd><span>plus is defined
plus is recursively defined (decreasing on 2nd argument)</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>The recursive call may not only be on direct subterms of the recursive
variable <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> but also on a deeper subterm and we can directly write
the function <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">mod2</span></span></code> which gives the remainder modulo 2 of a natural
number.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">mod2</span><span> (</span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>) : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">O</span><span>
| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> =&gt; </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-keyword">with</span><span>
         | </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">O</span><span>
         | </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">q</span><span> =&gt; </span><span class="coqdoc-var">mod2</span><span> </span><span class="coqdoc-var">q</span><span>
         </span><span class="coqdoc-keyword">end</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt><dd><span>mod2 is defined
mod2 is recursively defined (decreasing on 1st argument)</span></dd>
</dl>
</div>
</div>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Fixpoint</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span class="curlies">{<span>struct</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a>}</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>This variant allows defining simultaneously several mutual fixpoints.
It is especially useful when defining functions over mutually defined
inductive types.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>The size of trees and forests can be defined the following way:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">tree_size</span><span> (</span><span class="coqdoc-var">t</span><span>:</span><span class="coqdoc-var">tree</span><span>) : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">t</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">node</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">f</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">forest_size</span><span> </span><span class="coqdoc-var">f</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">forest_size</span><span> (</span><span class="coqdoc-var">f</span><span>:</span><span class="coqdoc-var">forest</span><span>) : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">leaf</span><span> </span><span class="coqdoc-var">b</span><span> =&gt; 1</span><span>
| </span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">t</span><span> </span><span class="coqdoc-var">f'</span><span> =&gt; (</span><span class="coqdoc-var">tree_size</span><span> </span><span class="coqdoc-var">t</span><span> + </span><span class="coqdoc-var">forest_size</span><span> </span><span class="coqdoc-var">f'</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt><dd><span>tree_size is defined
forest_size is defined
tree_size, forest_size are recursively defined
(decreasing respectively on 1st, 1st arguments)</span></dd>
</dl>
</div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="definitions-of-recursive-objects-in-co-inductive-types">
<span id="cofixpoint"></span><h4>Definitions of recursive objects in co-inductive types<a class="headerlink" href="#definitions-of-recursive-objects-in-co-inductive-types" title="このヘッドラインへのパーマリンク">¶</a></h4>
<dl class="cmd">
<dt id="coq:cmd.cofixpoint">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>CoFixpoint</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:cmd.cofixpoint" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command introduces a method for constructing an infinite object of a
coinductive type. For example, the stream containing all natural numbers can
be introduced applying the following method to the number <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code> (see
Section <a class="reference internal" href="#coinductive-types"><span class="std std-ref">Co-inductive types</span></a> for the definition of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">Stream</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">hd</span></span></code>
and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">tl</span></span></code>):</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">CoFixpoint</span><span> </span><span class="coqdoc-var">from</span><span> (</span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>) : </span><span class="coqdoc-var">Stream</span><span> := </span><span class="coqdoc-var">Seq</span><span> </span><span class="coqdoc-var">n</span><span> (</span><span class="coqdoc-var">from</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>)).</span></dt><dd><span>from is defined
from is corecursively defined</span></dd>
</dl>
</div>
<p>Oppositely to recursive ones, there is no decreasing argument in a
co-recursive definition. To be admissible, a method of construction must
provide at least one extra constructor of the infinite object for each
iteration. A syntactical guard condition is imposed on co-recursive
definitions in order to ensure this: each recursive call in the
definition must be protected by at least one constructor, and only by
constructors. That is the case in the former definition, where the single
recursive call of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">from</span></span></code> is guarded by an application of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">Seq</span></span></code>.
On the contrary, the following recursive function does not satisfy the
guard condition:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">CoFixpoint</span><span> </span><span class="coqdoc-var">filter</span><span> (</span><span class="coqdoc-var">p</span><span>:</span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>) (</span><span class="coqdoc-var">s</span><span>:</span><span class="coqdoc-var">Stream</span><span>) : </span><span class="coqdoc-var">Stream</span><span> :=</span><span>
  </span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">p</span><span> (</span><span class="coqdoc-var">hd</span><span> </span><span class="coqdoc-var">s</span><span>) </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">Seq</span><span> (</span><span class="coqdoc-var">hd</span><span> </span><span class="coqdoc-var">s</span><span>) (</span><span class="coqdoc-var">filter</span><span> </span><span class="coqdoc-var">p</span><span> (</span><span class="coqdoc-var">tl</span><span> </span><span class="coqdoc-var">s</span><span>)) </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">filter</span><span> </span><span class="coqdoc-var">p</span><span> (</span><span class="coqdoc-var">tl</span><span> </span><span class="coqdoc-var">s</span><span>).</span></dt><dd><span>The command has indeed failed with message:
Recursive definition of filter is ill-formed.
In environment
filter : (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Stream</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Stream</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
p : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
s : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Stream</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
Unguarded recursive call in &quot;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">filter</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">tl</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">s</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)&quot;.
Recursive definition is:
&quot;</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (p : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (s : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Stream</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) =&gt;
 </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">if</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">hd</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">s</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">then</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Seq</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">hd</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">s</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">filter</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">tl</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">s</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)) </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">else</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">filter</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">tl</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">s</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)&quot;.</span></dd>
</dl>
</div>
<p>The elimination of co-recursive definition is done lazily, i.e. the
definition is expanded only when it occurs at the head of an application
which is the argument of a case analysis expression. In any other
context, it is considered as a canonical expression which is completely
evaluated. We can test this using the command <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.eval" title="Eval"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Eval</span></code></a>, which computes
the normal forms of a term:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Eval</span><span> </span><span class="coqdoc-tactic">compute</span><span> </span><span class="coqdoc-tactic">in</span><span> (</span><span class="coqdoc-var">from</span><span> 0).</span></dt><dd><span>     = (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">cofix</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> from (n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Stream</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> := </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Seq</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">from</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">))) 0
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Stream</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
<dt><span class="coqdoc-keyword">Eval</span><span> </span><span class="coqdoc-tactic">compute</span><span> </span><span class="coqdoc-tactic">in</span><span> (</span><span class="coqdoc-var">hd</span><span> (</span><span class="coqdoc-var">from</span><span> 0)).</span></dt><dd><span>     = 0
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
<dt><span class="coqdoc-keyword">Eval</span><span> </span><span class="coqdoc-tactic">compute</span><span> </span><span class="coqdoc-tactic">in</span><span> (</span><span class="coqdoc-var">tl</span><span> (</span><span class="coqdoc-var">from</span><span> 0)).</span></dt><dd><span>     = (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">cofix</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> from (n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Stream</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> := </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Seq</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">from</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">))) 1
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Stream</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
</dl>
</div>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>CoFixpoint</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>As in the <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> command, it is possible to introduce a block of
mutually dependent methods.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="assertions-and-proofs">
<span id="assertions"></span><h3>Assertions and proofs<a class="headerlink" href="#assertions-and-proofs" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>An assertion states a proposition (or a type) of which the proof (or an
inhabitant of the type) is interactively built using tactics. The interactive
proof mode is described in Chapter <a class="reference internal" href="../proof-engine/proof-handling.html#proofhandling"><span class="std std-ref">Proof handling</span></a> and the tactics in
Chapter <a class="reference internal" href="../proof-engine/tactics.html#tactics"><span class="std std-ref">Tactics</span></a>. The basic assertion command is:</p>
<dl class="cmd">
<dt id="coq:cmd.theorem">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Theorem</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmd.theorem" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>After the statement is asserted, Coq needs a proof. Once a proof of
<a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> under the assumptions represented by <a class="reference internal" href="#grammar-token-binders"><code class="xref std std-token docutils literal notranslate"><span class="pre">binders</span></code></a> is given and
validated, the proof is generalized into a proof of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">forall</span></span> <a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a><span><span class="pre">,</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> and
the theorem is bound to the name <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> in the environment.</p>
<dl class="exn">
<dt id="coq:exn.the-term-term-has-type-type-which-should-be-set-prop-or-type">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>The</span> <span>term</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span>has</span> <span>type</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>which</span> <span>should</span> <span>be</span> <span>Set,</span> <span>Prop</span> <span>or</span> <span>Type.</span></span></code><a class="headerlink" href="#coq:exn.the-term-term-has-type-type-which-should-be-set-prop-or-type" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="exn">
<dt id="coq:exn.ident-already-exists-theorem">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>already</span> <span>exists.</span></span></code><a class="headerlink" href="#coq:exn.ident-already-exists-theorem" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The name you provided is already defined. You have then to choose
another name.</p>
</dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.lemma">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Lemma</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmdv.lemma" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:cmdv.remark">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Remark</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmdv.remark" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:cmdv.fact">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Fact</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmdv.fact" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:cmdv.corollary">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Corollary</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmdv.corollary" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:cmdv.proposition">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Proposition</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmdv.proposition" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>These commands are all synonyms of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">Theorem</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span><span class="pre">:</span></span> <span><span class="pre">type</span></span></span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Theorem</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>This command is useful for theorems that are proved by simultaneous induction
over a mutually inductive assumption, or that assert mutually dependent
statements in some mutual co-inductive type. It is equivalent to
<a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> or <a class="reference internal" href="#coq:cmd.cofixpoint" title="CoFixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">CoFixpoint</span></code></a> but using tactics to build the proof of
the statements (or the body of the specification, depending on the point of
view). The inductive or co-inductive types on which the induction or
coinduction has to be done is assumed to be non ambiguous and is guessed by
the system.</p>
<p>Like in a <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> or <a class="reference internal" href="#coq:cmd.cofixpoint" title="CoFixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">CoFixpoint</span></code></a> definition, the induction hypotheses
have to be used on <em>structurally smaller</em> arguments (for a <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a>) or
be <em>guarded by a constructor</em> (for a <a class="reference internal" href="#coq:cmd.cofixpoint" title="CoFixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">CoFixpoint</span></code></a>). The verification that
recursive proof arguments are correct is done only at the time of registering
the lemma in the environment. To know if the use of induction hypotheses is
correct at some time of the interactive development of a proof, use the
command <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.guarded" title="Guarded"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Guarded</span></code></a>.</p>
<p>The command can be used also with <a class="reference internal" href="#coq:cmdv.lemma" title="Lemma"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Lemma</span></code></a>, <a class="reference internal" href="#coq:cmdv.remark" title="Remark"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Remark</span></code></a>, etc. instead of
<a class="reference internal" href="#coq:cmd.theorem" title="Theorem"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Theorem</span></code></a>.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Definition</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code></dt>
<dd><p>This allows defining a term of type <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> using the proof editing
mode. It behaves as <a class="reference internal" href="#coq:cmd.theorem" title="Theorem"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Theorem</span></code></a> but is intended to be used in conjunction with
<a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmdv.defined" title="Defined"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Defined</span></code></a> in order to define a constant of which the computational
behavior is relevant.</p>
<p>The command can be used also with <a class="reference internal" href="#coq:cmdv.example" title="Example"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Example</span></code></a> instead of <a class="reference internal" href="#coq:cmd.definition" title="Definition"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Definition</span></code></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">参考</p>
<p><a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.opaque" title="Opaque"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Opaque</span></code></a>, <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.transparent" title="Transparent"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Transparent</span></code></a>, <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.unfold" title="unfold"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">unfold</span></code></a>.</p>
</div>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Let</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code></dt>
<dd><p>Like <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">Definition</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span><span class="pre">:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> except that the definition is
turned into a let-in definition generalized over the declarations depending
on it after closing the current section.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Fixpoint</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>This generalizes the syntax of <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> so that one or more bodies
can be defined interactively using the proof editing mode (when a
body is omitted, its type is mandatory in the syntax). When the block
of proofs is completed, it is intended to be ended by <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmdv.defined" title="Defined"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Defined</span></code></a>.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>CoFixpoint</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>This generalizes the syntax of <a class="reference internal" href="#coq:cmd.cofixpoint" title="CoFixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">CoFixpoint</span></code></a> so that one or more bodies
can be defined interactively using the proof editing mode.</p>
</dd></dl>

<p>A proof starts by the keyword <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.proof" title="Proof"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Proof</span></code></a>. Then Coq enters the proof editing mode
until the proof is completed. The proof editing mode essentially contains
tactics that are described in chapter <a class="reference internal" href="../proof-engine/tactics.html#tactics"><span class="std std-ref">Tactics</span></a>. Besides tactics, there
are commands to manage the proof editing mode. They are described in Chapter
<a class="reference internal" href="../proof-engine/proof-handling.html#proofhandling"><span class="std std-ref">Proof handling</span></a>.</p>
<p>When the proof is completed it should be validated and put in the environment
using the keyword <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.qed" title="Qed"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Qed</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<ol class="arabic simple">
<li><p>Several statements can be simultaneously asserted.</p></li>
<li><p>Not only other assertions but any vernacular command can be given
while in the process of proving a given assertion. In this case, the
command is understood as if it would have been given before the
statements still to be proved. Nonetheless, this practice is discouraged
and may stop working in future versions.</p></li>
<li><p>Proofs ended by <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.qed" title="Qed"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Qed</span></code></a> are declared opaque. Their content cannot be
unfolded (see <a class="reference internal" href="../proof-engine/tactics.html#performingcomputations"><span class="std std-ref">Performing computations</span></a>), thus
realizing some form of <em>proof-irrelevance</em>. To be able to unfold a
proof, the proof should be ended by <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmdv.defined" title="Defined"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Defined</span></code></a>.</p></li>
<li><p><a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.proof" title="Proof"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Proof</span></code></a> is recommended but can currently be omitted. On the opposite
side, <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.qed" title="Qed"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Qed</span></code></a> (or <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmdv.defined" title="Defined"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Defined</span></code></a>) is mandatory to validate a proof.</p></li>
<li><p>One can also use <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.admitted" title="Admitted"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Admitted</span></code></a> in place of <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.qed" title="Qed"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Qed</span></code></a> to turn the
current asserted statement into an axiom and exit the proof editing mode.</p></li>
</ol>
</div>
<dl class="footnote brackets">
<dt class="label" id="id6"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>This is similar to the expression “<em>entry</em> <span class="math notranslate nohighlight">\(\{\)</span> sep <em>entry</em>
<span class="math notranslate nohighlight">\(\}\)</span>” in standard BNF, or “<em>entry</em> <span class="math notranslate nohighlight">\((\)</span> sep <em>entry</em>
<span class="math notranslate nohighlight">\()\)</span>*” in the syntax of regular expressions.</p>
</dd>
<dt class="label" id="id7"><span class="brackets"><a class="fn-backref" href="#id4">2</a></span></dt>
<dd><p>Except if the inductive type is empty in which case there is no
equation that can be used to infer the return type.</p>
</dd>
</dl>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../credits.html" class="btn btn-neutral float-left" title="Credits" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="gallina-extensions.html" class="btn btn-neutral float-right" title="Gallina の拡張" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 1999-2018, Inria.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>