

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="ja" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="ja" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Gallina の拡張 &mdash; Coq 8.8.2 ドキュメント</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/notations.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/fonts.css" type="text/css" />
  <link rel="stylesheet" href="../_static/ansi.css" type="text/css" />
  <link rel="stylesheet" href="../_static/coqdoc.css" type="text/css" />
  <link rel="stylesheet" href="../_static/notations.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pre-text.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="next" title="The Coq library" href="coq-library.html" />
    <link rel="prev" title="仕様記述言語 Gallina" href="gallina-specification-language.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Coq
          

          
          </a>

          
            
            
              <div class="version">
                8.8.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">索引</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-cmdindex.html">Command index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-tacindex.html">Tactic index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-optindex.html">Flags, options and tables index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-exnindex.html">Errors and warnings index</a></li>
</ul>
<p class="caption"><span class="caption-text">はじめに</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">はじめに</a></li>
<li class="toctree-l1"><a class="reference internal" href="../credits.html">Credits</a></li>
</ul>
<p class="caption"><span class="caption-text">言語</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="gallina-specification-language.html">仕様記述言語 Gallina</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#"><span class="smallcaps">Gallina</span> の拡張</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#record-types">レコード型</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#primitive-projections">プリミティブ射影</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#primitive-record-types">プリミティブレコード型</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reduction">簡約</a></li>
<li class="toctree-l4"><a class="reference internal" href="#compatibility-projections-and-match">互換性射影と <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#variants-and-extensions-of-match">Variants and extensions of <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#multiple-and-nested-pattern-matching">Multiple and nested pattern matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pattern-matching-on-boolean-values-the-if-expression">Pattern-matching on boolean values: the if expression</a></li>
<li class="toctree-l3"><a class="reference internal" href="#irrefutable-patterns-the-destructuring-let-variants">Irrefutable patterns: the destructuring let variants</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#first-destructuring-let-syntax">First destructuring let syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="#second-destructuring-let-syntax">Second destructuring let syntax</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#controlling-pretty-printing-of-match-expressions">Controlling pretty-printing of match expressions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#printing-nested-patterns">Printing nested patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="#factorization-of-clauses-with-same-right-hand-side">Factorization of clauses with same right-hand side</a></li>
<li class="toctree-l4"><a class="reference internal" href="#use-of-a-default-clause">Use of a default clause</a></li>
<li class="toctree-l4"><a class="reference internal" href="#printing-of-wildcard-patterns">Printing of wildcard patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="#printing-of-the-elimination-predicate">Printing of the elimination predicate</a></li>
<li class="toctree-l4"><a class="reference internal" href="#printing-matching-on-irrefutable-patterns">Printing matching on irrefutable patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="#printing-matching-on-booleans">Printing matching on booleans</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#advanced-recursive-functions">高度な再帰関数</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-mechanism">Section mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-system">Module system</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#reserved-commands-inside-an-interactive-module">Reserved commands inside an interactive module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reserved-commands-inside-an-interactive-module-type">Reserved commands inside an interactive module type:</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#libraries-and-qualified-names">Libraries and qualified names</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#names-of-libraries">Names of libraries</a></li>
<li class="toctree-l3"><a class="reference internal" href="#qualified-names">Qualified names</a></li>
<li class="toctree-l3"><a class="reference internal" href="#libraries-and-filesystem">Libraries and filesystem</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#implicit-arguments">Implicit arguments</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-different-kinds-of-implicit-arguments">The different kinds of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#implicit-arguments-inferable-from-the-knowledge-of-other-arguments-of-a-function">Implicit arguments inferable from the knowledge of other arguments of a function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implicit-arguments-inferable-by-resolution">Implicit arguments inferable by resolution</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#maximal-or-non-maximal-insertion-of-implicit-arguments">Maximal or non maximal insertion of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#casual-use-of-implicit-arguments">Casual use of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#declaration-of-implicit-arguments">Declaration of implicit arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#implicit-argument-binders">Implicit Argument Binders</a></li>
<li class="toctree-l4"><a class="reference internal" href="#declaring-implicit-arguments">Declaring Implicit Arguments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#automatic-declaration-of-implicit-arguments">Automatic declaration of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mode-for-automatic-declaration-of-implicit-arguments">Mode for automatic declaration of implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#controlling-strict-implicit-arguments">Controlling strict implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#controlling-contextual-implicit-arguments">Controlling contextual implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#controlling-reversible-pattern-implicit-arguments">Controlling reversible-pattern implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#controlling-the-insertion-of-implicit-arguments-not-followed-by-explicit-arguments">Controlling the insertion of implicit arguments not followed by explicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#explicit-applications">Explicit applications</a></li>
<li class="toctree-l3"><a class="reference internal" href="#renaming-implicit-arguments">Renaming implicit arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#displaying-what-the-implicit-arguments-are">Displaying what the implicit arguments are</a></li>
<li class="toctree-l3"><a class="reference internal" href="#explicit-displaying-of-implicit-arguments-for-pretty-printing">Explicit displaying of implicit arguments for pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interaction-with-subtyping">Interaction with subtyping</a></li>
<li class="toctree-l3"><a class="reference internal" href="#deactivation-of-implicit-arguments-for-parsing">Deactivation of implicit arguments for parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#canonical-structures">正準構造</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implicit-types-of-variables">変数の暗黙の型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implicit-generalization">暗黙の一般化</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#coercions">コアーション</a></li>
<li class="toctree-l2"><a class="reference internal" href="#printing-constructions-in-full">全ての構成を表示する</a></li>
<li class="toctree-l2"><a class="reference internal" href="#printing-universes">ユニバースを表示する</a></li>
<li class="toctree-l2"><a class="reference internal" href="#existential-variables">Existential variables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#explicit-displaying-of-existential-instances-for-pretty-printing">Explicit displaying of existential instances for pretty-printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#solving-existential-variables-using-tactics">Solving existential variables using tactics</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="coq-library.html">The <span class="smallcaps">Coq</span> library</a></li>
<li class="toctree-l1"><a class="reference internal" href="cic.html">Calculus of Inductive Constructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="module-system.html">The Module System</a></li>
</ul>
<p class="caption"><span class="caption-text">証明エンジン</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/vernacular-commands.html">Vernacular commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/proof-handling.html">Proof handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/tactics.html">Tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/ltac.html">The tactic language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/detailed-tactic-examples.html">Detailed examples of tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html">The <span class="smallcaps">SSReflect</span> proof language</a></li>
</ul>
<p class="caption"><span class="caption-text">ユーザ拡張</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/syntax-extensions.html">Syntax extensions and interpretation scopes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/proof-schemes.html">Proof schemes</a></li>
</ul>
<p class="caption"><span class="caption-text">実用ツール</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coq-commands.html">The <span class="smallcaps">Coq</span> commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/utilities.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coqide.html"><span class="smallcaps">Coq</span> Integrated Development Environment</a></li>
</ul>
<p class="caption"><span class="caption-text">付録</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../addendum/extended-pattern-matching.html">Extended pattern matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/implicit-coercions.html">Implicit Coercions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/canonical-structures.html">正準構造</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/type-classes.html">型クラス</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/omega.html">Omega: a solver for quantifier-free problems in Presburger Arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/micromega.html">Micromega: tactics for solving arithmetic goals over ordered rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/extraction.html">Extraction of programs in <span class="smallcaps">OCaml</span> and Haskell</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/program.html">Program</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/ring.html">The ring and field tactic families</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/nsatz.html">Nsatz: tactics for proving equalities in integral domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/generalized-rewriting.html">Generalized rewriting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/parallel-proof-processing.html">Asynchronous and Parallel Proof Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/miscellaneous-extensions.html">Miscellaneous extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/universe-polymorphism.html">Polymorphic Universes</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../zebibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Coq</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li><span class="smallcaps">Gallina</span> の拡張</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/coq/coq/blob/master/doc/sphinx/language/gallina-extensions.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="math-preamble math notranslate nohighlight">
\[\begin{split}\newcommand{\alors}{\textsf{then}}
\newcommand{\alter}{\textsf{alter}}
\newcommand{\as}{\kw{as}}
\newcommand{\Assum}[3]{\kw{Assum}(#1)(#2:#3)}
\newcommand{\bool}{\textsf{bool}}
\newcommand{\case}{\kw{case}}
\newcommand{\conc}{\textsf{conc}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\conshl}{\textsf{cons\_hl}}
\newcommand{\Def}[4]{\kw{Def}(#1)(#2:=#3:#4)}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\EqSt}{\textsf{EqSt}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\false}{\textsf{false}}
\newcommand{\filter}{\textsf{filter}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\from}{\textsf{from}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\haslength}{\textsf{has\_length}}
\newcommand{\hd}{\textsf{hd}}
\newcommand{\ident}{\textsf{ident}}
\newcommand{\In}{\kw{in}}
\newcommand{\Ind}[4]{\kw{Ind}[#2](#3:=#4)}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[5]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)}
\newcommand{\Indpstr}[6]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)/{#6}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\lb}{\lambda}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\Prod}{\textsf{prod}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\si}{\textsf{if}}
\newcommand{\sinon}{\textsf{else}}
\newcommand{\Sort}{\cal S}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\true}{\textsf{true}}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\unfold}{\textsf{unfold}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\cal W\!F}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\cal W\!F}(#2)}
\newcommand{\WFTWOLINES}[2]{{\cal W\!F}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\newcommand{\zeros}{\textsf{zeros}}
\end{split}\]</div>
<div class="section" id="extensions-of-gallina">
<span id="extensionsofgallina"></span><h1><span class="smallcaps">Gallina</span> の拡張<a class="headerlink" href="#extensions-of-gallina" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p><span class="smallcaps">Gallina</span> は <span class="smallcaps">Coq</span> の核言語です。ここでは <span class="smallcaps">Gallina</span> の構文の拡張について説明します。</p>
<div class="section" id="record-types">
<span id="id1"></span><h2>レコード型<a class="headerlink" href="#record-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#coq:cmd.record" title="Record"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Record</span></code></a> は多くのプログラミング言語で行われるようにレコードを定義できるようにするマクロです。構文は以下で説明しています。実際は、<a class="reference internal" href="#coq:cmd.record" title="Record"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Record</span></code></a> マクロは普通のレコード型より一般的であり、”マニフェスト” 式のためのものでもあります。この場合、<a class="reference internal" href="#coq:cmd.record" title="Record"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Record</span></code></a> は ”シグネチャ” の定義をすることができます。</p>
<blockquote id="record-grammar">
<div><pre>
<strong id="grammar-token-record">record        </strong> ::=  <a class="reference internal" href="#grammar-token-record-keyword"><code class="xref docutils literal notranslate"><span class="pre">record_keyword</span></code></a> <code class="xref docutils literal notranslate"><span class="pre">record_body</span></code> with … with <code class="xref docutils literal notranslate"><span class="pre">record_body</span></code>
<strong id="grammar-token-record-keyword">record_keyword</strong> ::=  Record | Inductive | CoInductive
<strong id="grammar-token-field">field         </strong> ::=  <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> [ <a class="reference internal" href="gallina-specification-language.html#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a> ] : <a class="reference internal" href="gallina-specification-language.html#grammar-token-type"><code class="xref docutils literal notranslate"><span class="pre">type</span></code></a> [ where <a class="reference internal" href="../user-extensions/syntax-extensions.html#grammar-token-notation"><code class="xref docutils literal notranslate"><span class="pre">notation</span></code></a> ]
                    | <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> [ <a class="reference internal" href="gallina-specification-language.html#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a> ] [: <a class="reference internal" href="gallina-specification-language.html#grammar-token-type"><code class="xref docutils literal notranslate"><span class="pre">type</span></code></a> ] := <a class="reference internal" href="gallina-specification-language.html#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
</pre>
</div></blockquote>
<p>この式では:</p>
<dl class="cmd">
<dt id="coq:cmd.record">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Record</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="gallina-specification-language.html#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-sort"><span class="hole">sort</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">?</span></span> <span class="curlies">{ <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="gallina-specification-language.html#grammar-token-binders"><span class="hole">binders</span></a> <span>:</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span><span class="notation-sub">;</span></span> }</span></span></code><a class="headerlink" href="#coq:cmd.record" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>最初の識別子 <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> は定義されたレコードの名前であり、<a class="reference internal" href="gallina-specification-language.html#grammar-token-sort"><code class="xref std std-token docutils literal notranslate"><span class="pre">sort</span></code></a> はその型です。<code class="docutils literal notranslate"><span class="pre">:=</span></code> に続くオプショナルな識別子はそのコンストラクタです。それが省略された場合、デフォルトの名称である <code class="docutils literal notranslate"><span class="pre">Build_</span></code><a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> ここで <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> はレコード名、が使われます。<a class="reference internal" href="gallina-specification-language.html#grammar-token-sort"><code class="xref std std-token docutils literal notranslate"><span class="pre">sort</span></code></a> が省略された場合は、デフォルトのソートは <cite>Type</cite> です。ブラケットの中の識別子はフィールド名です。あるフィールド <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> が与えられた場合、その型は <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span> <span class="name"><span class="pre">binders</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">type</span></span></code> です。注目すべきは、特定の識別子の型は前に与えられた識別子に依存し得ることです。従ってフィールドの順序は重要です。最後に、<a class="reference internal" href="gallina-specification-language.html#grammar-token-binders"><code class="xref std std-token docutils literal notranslate"><span class="pre">binders</span></code></a> はレコードのパラメータです。</p>
<p>より一般的には、レコードは明示的に定義されたフィールド (別名 マニフェスト) を持ち得ます。例えば、<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">Record</span></span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <a class="reference internal" href="gallina-specification-language.html#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a> <span><span class="pre">:</span></span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-sort"><span class="hole"><span class="pre">sort</span></span></a> <span><span class="pre">:=</span></span> <span class="curlies"><span class="pre">{</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">₁</span></span> <span><span class="pre">:</span></span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span class="pre">₁</span></span> <span><span class="pre">;</span></span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">₂</span></span> <span><span class="pre">:=</span></span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">₂</span></span> <span><span class="pre">;</span></span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">₃</span></span> <span><span class="pre">:</span></span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span class="pre">₃</span></span> <span class="pre">}</span></span></span></code> があるとします。この場合 <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="gallina-specification-language.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span class="pre">₃</span></span></span></code> の正しさは <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">₂</span></span></span></code> のインスタンスである <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">₂</span></span></span></code> に依存し、<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">₂</span></span></span></code> は <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">₁</span></span></span></code> に依存するかもしれません。</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<blockquote>
<div><p>有理数の集合は以下のように定義されるかもしれません:</p>
</div></blockquote>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span class="coqdoc-keyword">Record</span><span> </span><span class="coqdoc-var">Rat</span><span> : </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-var">mkRat</span><span>
{</span><span class="coqdoc-var">sign</span><span> : </span><span class="coqdoc-var">bool</span><span>;</span><span>
</span><span class="coqdoc-var">top</span><span> : </span><span class="coqdoc-var">nat</span><span>;</span><span>
</span><span class="coqdoc-var">bottom</span><span> : </span><span class="coqdoc-var">nat</span><span>;</span><span>
</span><span class="coqdoc-var">Rat_bottom_cond</span><span> : 0 &lt;&gt; </span><span class="coqdoc-var">bottom</span><span>;</span><span>
</span><span class="coqdoc-var">Rat_irred_cond</span><span> :</span><span>
</span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span>:</span><span class="coqdoc-var">nat</span><span>, (</span><span class="coqdoc-var">x</span><span> * </span><span class="coqdoc-var">y</span><span>) = </span><span class="coqdoc-var">top</span><span> /\ (</span><span class="coqdoc-var">x</span><span> * </span><span class="coqdoc-var">z</span><span>) = </span><span class="coqdoc-var">bottom</span><span> -&gt; </span><span class="coqdoc-var">x</span><span> = 1}.</span></dt><dd><span>Rat is defined
sign is defined
top is defined
bottom is defined
Rat_bottom_cond is defined
Rat_irred_cond is defined</span></dd>
</dl>
</div>
</div>
<p>ここで注意すべきはフィールド <code class="docutils literal notranslate"><span class="pre">Rat_bottom_cond</span></code> がフィールド <code class="docutils literal notranslate"><span class="pre">bottom</span></code> に依存し、 <code class="docutils literal notranslate"><span class="pre">Rat_irred_cond</span></code> が <code class="docutils literal notranslate"><span class="pre">top</span></code> と <code class="docutils literal notranslate"><span class="pre">bottom</span></code> の両方に依存していることです。</p>
<p><code class="docutils literal notranslate"><span class="pre">Record</span></code> マクロによって行われる動作を見てみましょう。まずマクロは高々一つのコンストラクタをもつバリアント型定義を生成します: <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">Variant</span></span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span class="curlies"><span class="pre">{</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a> <span class="pre">}</span></span> <span><span class="pre">:</span></span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-sort"><span class="hole"><span class="pre">sort</span></span></a> <span><span class="pre">:=</span></span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">₀</span></span> <span class="curlies"><span class="pre">{</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a> <span class="pre">}</span></span></span></code> 。</p>
<p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> 型のオブジェクトを構築するには、レコードのフィールドを埋める適切な数の項を伴った <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">₀</span></span></span></code> コンストラクタを提供する必要があります。</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>有理数 <span class="math notranslate nohighlight">\(1/2\)</span> を定義してみましょう:</p>
<blockquote>
<div><div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Theorem</span><span> </span><span class="coqdoc-var">one_two_irred</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">x</span><span> * </span><span class="coqdoc-var">y</span><span> = 1 /\ </span><span class="coqdoc-var">x</span><span> * </span><span class="coqdoc-var">z</span><span> = 2 -&gt; </span><span class="coqdoc-var">x</span><span> = 1.</span></dt><dd class="coqtop-hidden"><span>1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x y z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span></dd>
<dt><span class="coqdoc-var">Admitted</span><span>.</span></dt><dd class="coqtop-hidden"><span>one_two_irred is declared</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">half</span><span> := </span><span class="coqdoc-var">mkRat</span><span> </span><span class="coqdoc-var">true</span><span> 1 2 (</span><span class="coqdoc-var">O_S</span><span> 1) </span><span class="coqdoc-var">one_two_irred</span><span>.</span></dt><dd class="coqtop-hidden"><span>half is defined</span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">half</span><span>.</span></dt><dd class="coqtop-hidden"><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">half</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Rat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
</dl>
</div>
</div></blockquote>
</div>
<blockquote id="record-named-fields-grammar">
<div><pre>
<strong id="grammar-token-record-term">record_term</strong> ::=  {| [<a class="reference internal" href="#grammar-token-field-def"><code class="xref docutils literal notranslate"><span class="pre">field_def</span></code></a> ; … ; <a class="reference internal" href="#grammar-token-field-def"><code class="xref docutils literal notranslate"><span class="pre">field_def</span></code></a>] |}
<strong id="grammar-token-field-def">field_def  </strong> ::=  name [binders] := <a class="reference internal" href="#grammar-token-record-term"><code class="xref docutils literal notranslate"><span class="pre">record_term</span></code></a>
</pre>
</div></blockquote>
<p>この文法で示されるように、代わりに以下の構文で名前付きフィールドを使うことでオブジェクトを作ることが出来ます。フィールドは特定の順序になっている必要はなく、もし足りないものが推論され得るか入力を促される (<a class="reference internal" href="../addendum/program.html#programs"><span class="std std-ref">Program</span></a> 参照) ならば、それらは全てが存在する必要もありません。</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">half'</span><span> :=</span><span>
  {| </span><span class="coqdoc-var">sign</span><span> := </span><span class="coqdoc-var">true</span><span>;</span><span>
     </span><span class="coqdoc-var">Rat_bottom_cond</span><span> := </span><span class="coqdoc-var">O_S</span><span> 1;</span><span>
     </span><span class="coqdoc-var">Rat_irred_cond</span><span> := </span><span class="coqdoc-var">one_two_irred</span><span> |}.</span></dt><dd><span>half' is defined</span></dd>
</dl>
</div>
<p>以下の設定は型の表示形式をコントロールします:</p>
<dl class="flag">
<dt id="coq:flag.printing-records">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Printing</span> <span>Records</span></span></code><a class="headerlink" href="#coq:flag.printing-records" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>セットすると、レコード構文 (上記) をデフォルト表示形式として使用します。</p>
</dd></dl>

<p>これらの表にエントリを追加することで特定の型の表示形式を上書きすることが出来ます。</p>
<dl class="table">
<dt id="coq:table.printing-record">
<em class="property"><span class="sigannot">Table</span></em> <code class="sig-name descname"><span class="notation"><span>Printing</span> <span>Record</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span></code><a class="headerlink" href="#coq:table.printing-record" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードとして表示される qualid の集合を指定します。qualid の集合を更新するには <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.add-table" title="Add &#64;table"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Add</span> <span class="pre">&#64;table</span></code></a> と <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.remove-table" title="Remove &#64;table"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Remove</span> <span class="pre">&#64;table</span></code></a> コマンドを使います。</p>
</dd></dl>

<dl class="table">
<dt id="coq:table.printing-constructor">
<em class="property"><span class="sigannot">Table</span></em> <code class="sig-name descname"><span class="notation"><span>Printing</span> <span>Constructor</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span></code><a class="headerlink" href="#coq:table.printing-constructor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンストラクタとして表示される qualid の集合を指定します。qualid の集合を更新するには <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.add-table" title="Add &#64;table"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Add</span> <span class="pre">&#64;table</span></code></a> と <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.remove-table" title="Remove &#64;table"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Remove</span> <span class="pre">&#64;table</span></code></a> コマンドを使います。</p>
</dd></dl>

<p>この構文はパターンマッチングに使うこともできます。</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Eval</span><span> </span><span class="coqdoc-tactic">compute</span><span> </span><span class="coqdoc-tactic">in</span><span> (</span><span>
  </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">half</span><span> </span><span class="coqdoc-keyword">with</span><span>
  | {| </span><span class="coqdoc-var">sign</span><span> := </span><span class="coqdoc-var">true</span><span>; </span><span class="coqdoc-var">top</span><span> := </span><span class="coqdoc-var">n</span><span> |} =&gt; </span><span class="coqdoc-var">n</span><span>
  | </span><span class="coqdoc-var">_</span><span> =&gt; 0</span><span>
  </span><span class="coqdoc-keyword">end</span><span>).</span></dt><dd><span>     = 1
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
</dl>
</div>
<p>そのマクロはさらに、それが可能な時は <cite>ident</cite> 型のオブジェクトをデストラクトするための射影関数をも生成します。これらの射影関数は対応するフィールド名から与えられます。もしフィールドの名前が <cite>_</cite> ならばそれのための射影は構築されません。我々の扱っている例では:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Eval</span><span> </span><span class="coqdoc-tactic">compute</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">top</span><span> </span><span class="coqdoc-var">half</span><span>.</span></dt><dd><span>     = 1
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
<dt><span class="coqdoc-keyword">Eval</span><span> </span><span class="coqdoc-tactic">compute</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">bottom</span><span> </span><span class="coqdoc-var">half</span><span>.</span></dt><dd><span>     = 2
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
<dt><span class="coqdoc-keyword">Eval</span><span> </span><span class="coqdoc-tactic">compute</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">Rat_bottom_cond</span><span> </span><span class="coqdoc-var">half</span><span>.</span></dt><dd><span>     = </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">O_S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1
     : 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bottom</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">half</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
</dl>
</div>
<p>射影のためドット記法に基づいた代替構文が使用可能です:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Eval</span><span> </span><span class="coqdoc-tactic">compute</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">half</span><span>.(</span><span class="coqdoc-var">top</span><span>).</span></dt><dd><span>     = 1
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
</dl>
</div>
<p>それは以下によって表示を有効にすることが出来ます。</p>
<dl class="flag">
<dt id="coq:flag.printing-projections">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Printing</span> <span>Projections</span></span></code><a class="headerlink" href="#coq:flag.printing-projections" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Set</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-var">Projections</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">top</span><span> </span><span class="coqdoc-var">half</span><span>.</span></dt><dd><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">half</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.(</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">top</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
</dl>
</div>
</div>
<blockquote id="record-projections-grammar">
<div><pre>
<strong id="grammar-token-projection">projection</strong> ::=  projection `.` ( <a class="reference internal" href="gallina-specification-language.html#grammar-token-qualid"><code class="xref docutils literal notranslate"><span class="pre">qualid</span></code></a> )
                | projection `.` ( <a class="reference internal" href="gallina-specification-language.html#grammar-token-qualid"><code class="xref docutils literal notranslate"><span class="pre">qualid</span></code></a> <a class="reference internal" href="gallina-specification-language.html#grammar-token-arg"><code class="xref docutils literal notranslate"><span class="pre">arg</span></code></a> … <a class="reference internal" href="gallina-specification-language.html#grammar-token-arg"><code class="xref docutils literal notranslate"><span class="pre">arg</span></code></a> )
                | projection `.` ( &#64;<a class="reference internal" href="gallina-specification-language.html#grammar-token-qualid"><code class="xref docutils literal notranslate"><span class="pre">qualid</span></code></a> <a class="reference internal" href="gallina-specification-language.html#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> … <a class="reference internal" href="gallina-specification-language.html#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> )
</pre>
<p>レコード射影構文</p>
</div></blockquote>
<p>対応する文法規則は前述の文法の中で与えられています。<cite>qualid</cite> が射影を意味するとき、<cite>term.(qualid)</cite> という構文は <cite>qualid term</cite> と等しく、<cite>term.(qualid</cite> <cite>arg</cite><span class="math notranslate nohighlight">\(_{1}\)</span> <cite>arg</cite><span class="math notranslate nohighlight">\(_{n}\)</span> <cite>)</cite> は <cite>qualid</cite> <cite>arg</cite><span class="math notranslate nohighlight">\(_{1}\)</span> <cite>…</cite> <cite>arg</cite><span class="math notranslate nohighlight">\(_{n}\)</span> <cite>term</cite> と、<cite>term.(&#64;qualid</cite> <cite>term</cite><span class="math notranslate nohighlight">\(_{1}\)</span> <cite>term</cite><span class="math notranslate nohighlight">\(_{n}\)</span> <cite>)</cite> という構文は <cite>&#64;qualid</cite> <cite>term</cite><span class="math notranslate nohighlight">\(_{1}\)</span> <cite>…</cite> <cite>term</cite><span class="math notranslate nohighlight">\(_{n}\)</span> <cite>term</cite> と等しくなります。いずれの場合も、<cite>term</cite> は射影されたオブジェクトであり、他の引数は帰納型のパラメータです。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><code class="docutils literal notranslate"><span class="pre">Record</span></code> キーワードで定義されたレコードは再帰することは許されません (レコード名への参照がそのフィールドの型の中にあるとエラーが起きる)。再帰的レコードを定義するためには、<code class="docutils literal notranslate"><span class="pre">Inductive</span></code> と <code class="docutils literal notranslate"><span class="pre">CoInductive</span></code> キーワードを使うことができ、結果は帰納的または余帰納的レコードになります。注意点として、しかしながら、レコードは相互帰納的 (または余帰納的) 定義の中に現れることはできません。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>帰納スキームは帰納的レコードについて自動的に生成される。<code class="docutils literal notranslate"><span class="pre">Record</span></code> キーワードによって定義された非-再帰的レコードの帰納スキームの自動生成は <code class="docutils literal notranslate"><span class="pre">Nonrecursive</span> <span class="pre">Elimination</span> <span class="pre">Schemes</span></code> オプション (<a class="reference internal" href="../user-extensions/proof-schemes.html#proofschemes-induction-principles"><span class="std std-ref">Generation of induction principles with Scheme</span></a> 参照) によって有効化することができる。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><code class="docutils literal notranslate"><span class="pre">Structure</span></code> はキーワード <code class="docutils literal notranslate"><span class="pre">Record</span></code> の別名です。</p>
</div>
<dl class="warn">
<dt id="coq:warn.ident-cannot-be-defined">
<em class="property"><span class="sigannot">Warning</span></em> <code class="sig-name descname"><span class="notation"><a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>cannot</span> <span>be</span> <span>defined.</span></span></code><a class="headerlink" href="#coq:warn.ident-cannot-be-defined" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>射影の定義が不可能なことが起こり得ます。このメッセージにはこの不可能性の説明が続きます。3通りの可能性があります。</p>
<ol class="arabic simple">
<li><p>名前 <cite>ident</cite> が既に環境中に存在する (<a class="reference internal" href="gallina-specification-language.html#coq:cmdv.axiom" title="Axiom"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Axiom</span></code></a> 参照)。</p></li>
<li><p><cite>ident</cite> のボディーは <cite>ident</cite> に不正な除去を使っている (<a class="reference internal" href="gallina-specification-language.html#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> と <a class="reference internal" href="cic.html#destructors"><span class="std std-ref">Destructors</span></a> 参照)。</p></li>
<li><p><cite>ident</cite> の射影の型がそれ自身の以前の射影に依存していると定義できません。</p></li>
</ol>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.records-declared-with-the-keyword-record-or-structure-cannot-be-recursive">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Records</span> <span>declared</span> <span>with</span> <span>the</span> <span>keyword</span> <span>Record</span> <span>or</span> <span>Structure</span> <span>cannot</span> <span>be</span> <span>recursive.</span></span></code><a class="headerlink" href="#coq:exn.records-declared-with-the-keyword-record-or-structure-cannot-be-recursive" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコード名 <cite>ident</cite> がそのフィールドの型の中に現れているが、<code class="docutils literal notranslate"><span class="pre">Record</span></code> キーワードを使っています。代わりにキーワード <code class="docutils literal notranslate"><span class="pre">Inductive</span></code> または <code class="docutils literal notranslate"><span class="pre">CoInductive</span></code> を使ってください。</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.cannot-handle-mutually-co-inductive-records">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Cannot</span> <span>handle</span> <span>mutually</span> <span>(co)inductive</span> <span>records.</span></span></code><a class="headerlink" href="#coq:exn.cannot-handle-mutually-co-inductive-records" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードは、レコードのみであっても標準定義との混合であっても、相互帰納的 (または余帰納的) 定義の一部として定義することはできません。</p>
</dd></dl>

<p>コンストラクタが一つの帰納的定義を定義しているとき、セクション <a class="reference internal" href="gallina-specification-language.html#gallina-inductive-definitions"><span class="std std-ref">Inductive definitions</span></a> で説明される帰納的定義の全てのエラーも起こる可能性があります。</p>
<div class="admonition seealso">
<p class="admonition-title">参考</p>
<p>そのチャプターのセクション <a class="reference internal" href="../addendum/implicit-coercions.html#coercions-classes-as-records"><span class="std std-ref">Classes as Records</span></a> のコアーションとレコードはコアーションに費やされています。</p>
</div>
<div class="section" id="primitive-projections">
<span id="id2"></span><h3>プリミティブ射影<a class="headerlink" href="#primitive-projections" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="flag">
<dt id="coq:flag.primitive-projections">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Primitive</span> <span>Projections</span></span></code><a class="headerlink" href="#coq:flag.primitive-projections" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>後続のレコードを (<code class="docutils literal notranslate"><span class="pre">Inductive</span></code> や <code class="docutils literal notranslate"><span class="pre">CoInductive</span></code> コマンドだとしても) 定義するときにプリミティブ射影を有効にします。. プリミティブ射影は Calculus of Inductive Constructions を新たな二項構築子 <cite>r.(p)</cite> で拡張し、これはあるレコードオブジェクト <cite>r</cite> に適用されるプリミティブ射影 <cite>p</cite> です (つまり、プリミティブ射影は常に適用されます)。そのレコード型がパラメータを持っていたとしても、これらは射影の適用には現れず、パラメータ化されたレコードを操作するときの項のサイズや型検査時間を大幅に減少させます。ユーザレベルでは、いくらか注目すべき違いはありますが、プリミティブ射影は普通に定義されたそれを置き換えるのに使うことが出来ます。</p>
</dd></dl>

<dl class="flag">
<dt id="coq:flag.printing-primitive-projection-parameters">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Printing</span> <span>Primitive</span> <span>Projection</span> <span>Parameters</span></span></code><a class="headerlink" href="#coq:flag.printing-primitive-projection-parameters" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この互換オプションは表示時に内部的に省略されたパラメータを再構成します (たとえばそれらがカーネルに操作された実際のASTには存在しないものであっても)。</p>
</dd></dl>

<dl class="flag">
<dt id="coq:flag.printing-primitive-projection-compatibility">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Printing</span> <span>Primitive</span> <span>Projection</span> <span>Compatibility</span></span></code><a class="headerlink" href="#coq:flag.printing-primitive-projection-compatibility" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この互換性オプション (デフォルトで有効) はプリミティブレコード上でのパターンマッチの表示を抑制します。</p>
</dd></dl>

<div class="section" id="primitive-record-types">
<h4>プリミティブレコード型<a class="headerlink" href="#primitive-record-types" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><a class="reference internal" href="#coq:flag.primitive-projections" title="Primitive Projections"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Primitive</span> <span class="pre">Projections</span></code></a> オプションが有効な時、レコード型の定義は意味を変えます。ある型がプリミティブ射影によって定義されたとき、その <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span></code> による構成は無効化されます (<a class="reference internal" href="#primitive-projections"><span class="std std-ref">プリミティブ射影</span></a> 参照). (余)帰納的型を排除するためには、その定義されたプリミティブ射影を使わなければならない。</p>
<p>互換性のため、カーネルにより操作された実際のAST中には存在しないものであっても項を表示する時にパラメータはユーザに表示されます。これは <a class="reference internal" href="#coq:flag.printing-primitive-projection-parameters" title="Printing Primitive Projection Parameters"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">Primitive</span> <span class="pre">Projection</span> <span class="pre">Parameters</span></code></a> フラグをアンセットすることで変更できます。さらなる互換表示は <code class="docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">Primitive</span> <span class="pre">Projection</span> <span class="pre">Compatibility</span></code> オプションで非有効化することができ、これはプリミティブレコード上のパターンマッチを抑制します。</p>
<p>今のところプリミティブレコード型を導入するには二つの方法があります。</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Record</span></code> コマンドを使うと、その場合はその型が非再帰的である必要があります。定義された型は定義的に eta 変換を使うことが出来、それは <cite>r</cite> <code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">Build_</span></code><cite>R</cite> <code class="docutils literal notranslate"><span class="pre">(</span></code><cite>r</cite><code class="docutils literal notranslate"><span class="pre">.(</span></code><cite>p</cite><span class="math notranslate nohighlight">\(_{1}\)</span><code class="docutils literal notranslate"><span class="pre">)</span> <span class="pre">…</span></code> <cite>r</cite><code class="docutils literal notranslate"><span class="pre">.(</span></code><cite>p</cite><span class="math notranslate nohighlight">\(_{n}\)</span><code class="docutils literal notranslate"><span class="pre">))</span></code> というレコードの全射ペアリングの一般的な形です。その上、Eta 変換はこれらの型について依存除去を定義することが出来ます。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Inductive</span></code> と <code class="docutils literal notranslate"><span class="pre">CoInductive</span></code> コマンドを使うのは、定義のボディーが <code class="docutils literal notranslate"><span class="pre">Build_</span></code><cite>R</cite> <code class="docutils literal notranslate"><span class="pre">{</span></code> <cite>p</cite><span class="math notranslate nohighlight">\(_{1}\)</span> <code class="docutils literal notranslate"><span class="pre">:</span></code> <cite>t</cite><span class="math notranslate nohighlight">\(_{1}\)</span><code class="docutils literal notranslate"><span class="pre">;</span> <span class="pre">…</span> <span class="pre">;</span></code> <cite>p</cite><span class="math notranslate nohighlight">\(_{n}\)</span> <code class="docutils literal notranslate"><span class="pre">:</span></code> <cite>t</cite><span class="math notranslate nohighlight">\(_{n}\)</span> <code class="docutils literal notranslate"><span class="pre">}</span></code> という形のレコード定義の時です。この場合は型は再帰でき、eta 変換は許されません。これらの種類のレコード型は、依存除去が出来ず、非依存場合分けのみが定義できるという意味での伝統的なバージョンとは異なります。</p></li>
</ol>
</div>
<div class="section" id="reduction">
<h4>簡約<a class="headerlink" href="#reduction" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>プリミティブ射影の基本的な簡約規則は <cite>p</cite><span class="math notranslate nohighlight">\(_{i}\)</span> <code class="docutils literal notranslate"><span class="pre">(Build_</span></code><cite>R</cite> <cite>t</cite><span class="math notranslate nohighlight">\(_{1}\)</span> … <cite>t</cite><span class="math notranslate nohighlight">\(_{n}\)</span><code class="docutils literal notranslate"><span class="pre">)</span></code> <span class="math notranslate nohighlight">\({\rightarrow_{\iota}}\)</span> <cite>t</cite><span class="math notranslate nohighlight">\(_{i}\)</span> です。しかし、<span class="math notranslate nohighlight">\({\delta}\)</span> フラグを考慮すると、射影は 畳み込み または 非畳み込み という二つの状態になり得ます。非畳み込みプリミティブ射影適用は上の規則にしたがい、一方畳み込み版は非畳み込み版へデルタ簡約します。これは通常の定数の展開規則と細部に渡って似ています。特に射影は、<code class="docutils literal notranslate"><span class="pre">Arguments</span></code> コマンドの通常の <code class="docutils literal notranslate"><span class="pre">simpl</span></code> フラグに従います。現在のところはユーザレベルで非畳み込みプリミティブ射影を入力する方法は無く、非畳み込みプリミティブ射影をマッチとして表示し、それらを畳み込みのそれと区別するには <a class="reference internal" href="#coq:flag.printing-primitive-projection-compatibility" title="Printing Primitive Projection Compatibility"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">Primitive</span> <span class="pre">Projection</span> <span class="pre">Compatibility</span></code></a> を使わなければなりません。</p>
</div>
<div class="section" id="compatibility-projections-and-match">
<h4>互換性射影と <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span></code><a class="headerlink" href="#compatibility-projections-and-match" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>通常のレコード型との互換性を緩和するため、各プリミティブ射影は通常のパラメータと、引数としてそのレコード型のオブジェクトとを取り、そのボディーが同じ名前の非畳み込みプリミティブ射影の適用であるものとしても定義されます。これらの定数はその射影の部分適用の精緻化のときに使われます。:flag`Printing Primitive Projection Parameters` オプションがオフになっているとそれらとプリミティブ射影の適用と区別することが出来ます。プリミティブ射影適用のときは、パラメータはアンダースコアとして表示される一方、互換性射影は普通に表示されます。</p>
<p>さらに、プリミティブレコード上のユーザ記述の <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span></code> は射影の代入への脱糖され、それらは <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span></code> として表示することは出来ません。</p>
</div>
</div>
</div>
<div class="section" id="variants-and-extensions-of-match">
<h2>Variants and extensions of <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span></code><a class="headerlink" href="#variants-and-extensions-of-match" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="multiple-and-nested-pattern-matching">
<span id="mult-match"></span><h3>Multiple and nested pattern matching<a class="headerlink" href="#multiple-and-nested-pattern-matching" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The basic version of <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span></code> allows pattern matching on simple
patterns. As an extension, multiple nested patterns or disjunction of
patterns are allowed, as in ML-like languages.</p>
<p>The extension just acts as a macro that is expanded during parsing
into a sequence of match on simple patterns. Especially, a
construction defined using the extended match is generally printed
under its expanded form (see <a class="reference internal" href="#coq:flag.printing-matching" title="Printing Matching"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">Matching</span></code></a>).</p>
<div class="admonition seealso">
<p class="admonition-title">参考</p>
<p><a class="reference internal" href="../addendum/extended-pattern-matching.html#extendedpatternmatching"><span class="std std-ref">Extended pattern matching</span></a>.</p>
</div>
</div>
<div class="section" id="pattern-matching-on-boolean-values-the-if-expression">
<span id="if-then-else"></span><h3>Pattern-matching on boolean values: the if expression<a class="headerlink" href="#pattern-matching-on-boolean-values-the-if-expression" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>For inductive types with exactly two constructors and for pattern matching
expressions that do not depend on the arguments of the constructors, it is possible
to use a <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">…</span> <span class="pre">then</span> <span class="pre">…</span> <span class="pre">else</span></code> notation. For instance, the definition</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">not</span><span> (</span><span class="coqdoc-var">b</span><span>:</span><span class="coqdoc-var">bool</span><span>) :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">true</span><span> =&gt; </span><span class="coqdoc-var">false</span><span>
| </span><span class="coqdoc-var">false</span><span> =&gt; </span><span class="coqdoc-var">true</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt><dd><span>not is defined</span></dd>
</dl>
</div>
<p>can be alternatively written</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">not</span><span> (</span><span class="coqdoc-var">b</span><span>:</span><span class="coqdoc-var">bool</span><span>) := </span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">false</span><span> </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">true</span><span>.</span></dt><dd><span>not is defined</span></dd>
</dl>
</div>
<p>More generally, for an inductive type with constructors <cite>C</cite><span class="math notranslate nohighlight">\(_{1}\)</span> and <cite>C</cite><span class="math notranslate nohighlight">\(_{2}\)</span>,
we have the following equivalence</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>if term [dep_ret_type] then term₁ else term₂ ≡
match term [dep_ret_type] with
| C₁ _ … _ =&gt; term₁
| C₂ _ … _ =&gt; term₂
end
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">x</span><span> (</span><span class="coqdoc-var">H</span><span>:{</span><span class="coqdoc-var">x</span><span>=0}+{</span><span class="coqdoc-var">x</span><span>&lt;&gt;0}) =&gt;</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">H</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-tactic">left</span><span> </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-var">true</span><span>
| </span><span class="coqdoc-tactic">right</span><span> </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-var">false</span><span>
</span><span class="coqdoc-keyword">end</span><span>).</span></dt><dd><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (H : </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">{</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">}</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">+</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">{</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">}</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">if</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">H</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">then</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">true</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">else</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">false</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">{</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">}</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">+</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">{</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">}</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
</dl>
</div>
</div>
<p>Notice that the printing uses the <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">if</span></span></code> syntax because <cite>sumbool</cite> is
declared as such (see <a class="reference internal" href="#controlling-match-pp"><span class="std std-ref">Controlling pretty-printing of match expressions</span></a>).</p>
</div>
<div class="section" id="irrefutable-patterns-the-destructuring-let-variants">
<span id="irrefutable-patterns"></span><h3>Irrefutable patterns: the destructuring let variants<a class="headerlink" href="#irrefutable-patterns-the-destructuring-let-variants" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Pattern-matching on terms inhabiting inductive type having only one
constructor can be alternatively written using <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">let</span></span> <span class="error"><span class="pre">…</span></span> <span class="keyword"><span class="pre">in</span></span> <span class="error"><span class="pre">…</span></span></code>
constructions. There are two variants of them.</p>
<div class="section" id="first-destructuring-let-syntax">
<h4>First destructuring let syntax<a class="headerlink" href="#first-destructuring-let-syntax" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The expression <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">let</span></span> <span class="operator"><span class="pre">(</span></span></code><cite>ident</cite><span class="math notranslate nohighlight">\(_{1}\)</span><code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">,</span></span> <span class="error"><span class="pre">…</span></span> <span class="operator"><span class="pre">,</span></span></code> <cite>ident</cite><span class="math notranslate nohighlight">\(_{n}\)</span><code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">:=</span></span></code> <cite>term</cite><span class="math notranslate nohighlight">\(_{0}\)</span><code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">in</span></span></code> <cite>term</cite><span class="math notranslate nohighlight">\(_{1}\)</span> performs
case analysis on <cite>term</cite><span class="math notranslate nohighlight">\(_{0}\)</span> which must be in an inductive type with one
constructor having itself <span class="math notranslate nohighlight">\(n\)</span> arguments. Variables <cite>ident</cite><span class="math notranslate nohighlight">\(_{1}\)</span> … <cite>ident</cite><span class="math notranslate nohighlight">\(_{n}\)</span> are
bound to the <span class="math notranslate nohighlight">\(n\)</span> arguments of the constructor in expression <cite>term</cite><span class="math notranslate nohighlight">\(_{1}\)</span>. For
instance, the definition</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">fst</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) (</span><span class="coqdoc-var">H</span><span>:</span><span class="coqdoc-var">A</span><span> * </span><span class="coqdoc-var">B</span><span>) := </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">H</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">pair</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> =&gt; </span><span class="coqdoc-var">x</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt><dd><span>fst is defined</span></dd>
</dl>
</div>
<p>can be alternatively written</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">fst</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) (</span><span class="coqdoc-var">p</span><span>:</span><span class="coqdoc-var">A</span><span> * </span><span class="coqdoc-var">B</span><span>) := </span><span class="coqdoc-keyword">let</span><span> (</span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">_</span><span>) := </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">x</span><span>.</span></dt><dd><span>fst is defined</span></dd>
</dl>
</div>
<p>Notice that reduction is different from regular <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">let</span></span> <span class="error"><span class="pre">…</span></span> <span class="keyword"><span class="pre">in</span></span> <span class="error"><span class="pre">…</span></span></code>
construction since it happens only if <cite>term</cite><span class="math notranslate nohighlight">\(_{0}\)</span> is in constructor form.
Otherwise, the reduction is blocked.</p>
<p>The pretty-printing of a definition by matching on a irrefutable
pattern can either be done using <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span></code> or the <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">let</span></span></code> construction
(see Section <a class="reference internal" href="#controlling-match-pp"><span class="std std-ref">Controlling pretty-printing of match expressions</span></a>).</p>
<p>If term inhabits an inductive type with one constructor <cite>C</cite>, we have an
equivalence between</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>let (ident₁, …, identₙ) [dep_ret_type] := term in term&#39;
</pre></div>
</div>
<p>and</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>match term [dep_ret_type] with
C ident₁ … identₙ =&gt; term&#39;
end
</pre></div>
</div>
</div>
<div class="section" id="second-destructuring-let-syntax">
<h4>Second destructuring let syntax<a class="headerlink" href="#second-destructuring-let-syntax" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>Another destructuring let syntax is available for inductive types with
one constructor by giving an arbitrary pattern instead of just a tuple
for all the arguments. For example, the preceding example can be
written:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">fst</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) (</span><span class="coqdoc-var">p</span><span>:</span><span class="coqdoc-var">A</span><span>*</span><span class="coqdoc-var">B</span><span>) := </span><span class="coqdoc-keyword">let</span><span> '</span><span class="coqdoc-var">pair</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">_</span><span> := </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">x</span><span>.</span></dt><dd><span>fst is defined</span></dd>
</dl>
</div>
<p>This is useful to match deeper inside tuples and also to use notations for the pattern, as the syntax <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">let</span></span> <span class="error"><span class="pre">’</span></span><span class="name"><span class="pre">p</span></span> <span class="operator"><span class="pre">:=</span></span> <span class="name"><span class="pre">t</span></span> <span class="keyword"><span class="pre">in</span></span> <span class="name"><span class="pre">b</span></span></code> allows arbitrary patterns to do the deconstruction. 例えば:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">deep_tuple</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) (</span><span class="coqdoc-var">x</span><span>:(</span><span class="coqdoc-var">A</span><span>*</span><span class="coqdoc-var">A</span><span>)*(</span><span class="coqdoc-var">A</span><span>*</span><span class="coqdoc-var">A</span><span>)) : </span><span class="coqdoc-var">A</span><span>*</span><span class="coqdoc-var">A</span><span>*</span><span class="coqdoc-var">A</span><span>*</span><span class="coqdoc-var">A</span><span> :=</span><span>
</span><span class="coqdoc-keyword">let</span><span> '((</span><span class="coqdoc-var">a</span><span>,</span><span class="coqdoc-var">b</span><span>), (</span><span class="coqdoc-var">c</span><span>, </span><span class="coqdoc-var">d</span><span>)) := </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-tactic">in</span><span> (</span><span class="coqdoc-var">a</span><span>,</span><span class="coqdoc-var">b</span><span>,</span><span class="coqdoc-var">c</span><span>,</span><span class="coqdoc-var">d</span><span>).</span></dt><dd><span>deep_tuple is defined</span></dd>
<dt><span class="coqdoc-keyword">Notation</span><span> &quot; x 'With' p &quot; := (</span><span class="coqdoc-var">exist</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">p</span><span>) (</span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 20).</span></dt><dd><span>Identifier 'With' now a keyword</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">proj1_sig'</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) (</span><span class="coqdoc-var">P</span><span>:</span><span class="coqdoc-var">A</span><span>-&gt;</span><span class="coqdoc-keyword">Prop</span><span>) (</span><span class="coqdoc-var">t</span><span>:{ </span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">A</span><span> | </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">x</span><span> }) : </span><span class="coqdoc-var">A</span><span> :=</span><span>
</span><span class="coqdoc-keyword">let</span><span> '</span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">With</span><span> </span><span class="coqdoc-var">p</span><span> := </span><span class="coqdoc-var">t</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">x</span><span>.</span></dt><dd><span>proj1_sig' is defined</span></dd>
</dl>
</div>
<p>When printing definitions which are written using this construct it
takes precedence over let printing directives for the datatype under
consideration (see Section <a class="reference internal" href="#controlling-match-pp"><span class="std std-ref">Controlling pretty-printing of match expressions</span></a>).</p>
</div>
</div>
<div class="section" id="controlling-pretty-printing-of-match-expressions">
<span id="controlling-match-pp"></span><h3>Controlling pretty-printing of match expressions<a class="headerlink" href="#controlling-pretty-printing-of-match-expressions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The following commands give some control over the pretty-printing
of <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span></code> expressions.</p>
<div class="section" id="printing-nested-patterns">
<h4>Printing nested patterns<a class="headerlink" href="#printing-nested-patterns" title="このヘッドラインへのパーマリンク">¶</a></h4>
<dl class="flag">
<dt id="coq:flag.printing-matching">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Printing</span> <span>Matching</span></span></code><a class="headerlink" href="#coq:flag.printing-matching" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The Calculus of Inductive Constructions knows pattern matching only
over simple patterns. It is however convenient to re-factorize nested
pattern matching into a single pattern matching over a nested
pattern.</p>
<p>When this option is on (default), <span class="smallcaps">Coq</span>’s printer tries to do such
limited re-factorization.
Turning it off tells <span class="smallcaps">Coq</span> to print only simple pattern matching problems
in the same way as the <span class="smallcaps">Coq</span> kernel handles them.</p>
</dd></dl>

</div>
<div class="section" id="factorization-of-clauses-with-same-right-hand-side">
<h4>Factorization of clauses with same right-hand side<a class="headerlink" href="#factorization-of-clauses-with-same-right-hand-side" title="このヘッドラインへのパーマリンク">¶</a></h4>
<dl class="flag">
<dt id="coq:flag.printing-factorizable-match-patterns">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Printing</span> <span>Factorizable</span> <span>Match</span> <span>Patterns</span></span></code><a class="headerlink" href="#coq:flag.printing-factorizable-match-patterns" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>When several patterns share the same right-hand side, it is additionally
possible to share the clauses using disjunctive patterns. Assuming that the
printing matching mode is on, this option (on by default) tells <span class="smallcaps">Coq</span>'s
printer to try to do this kind of factorization.</p>
</dd></dl>

</div>
<div class="section" id="use-of-a-default-clause">
<h4>Use of a default clause<a class="headerlink" href="#use-of-a-default-clause" title="このヘッドラインへのパーマリンク">¶</a></h4>
<dl class="flag">
<dt id="coq:flag.printing-allow-match-default-clause">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Printing</span> <span>Allow</span> <span>Match</span> <span>Default</span> <span>Clause</span></span></code><a class="headerlink" href="#coq:flag.printing-allow-match-default-clause" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>When several patterns share the same right-hand side which do not depend on the
arguments of the patterns, yet an extra factorization is possible: the
disjunction of patterns can be replaced with a <cite>_</cite> default clause. Assuming that
the printing matching mode and the factorization mode are on, this option (on by
default) tells <span class="smallcaps">Coq</span>'s printer to use a default clause when relevant.</p>
</dd></dl>

</div>
<div class="section" id="printing-of-wildcard-patterns">
<h4>Printing of wildcard patterns<a class="headerlink" href="#printing-of-wildcard-patterns" title="このヘッドラインへのパーマリンク">¶</a></h4>
<dl class="flag">
<dt id="coq:flag.printing-wildcard">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Printing</span> <span>Wildcard</span></span></code><a class="headerlink" href="#coq:flag.printing-wildcard" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Some variables in a pattern may not occur in the right-hand side of
the pattern matching clause. When this option is on (default), the
variables having no occurrences in the right-hand side of the
pattern matching clause are just printed using the wildcard symbol
“_”.</p>
</dd></dl>

</div>
<div class="section" id="printing-of-the-elimination-predicate">
<h4>Printing of the elimination predicate<a class="headerlink" href="#printing-of-the-elimination-predicate" title="このヘッドラインへのパーマリンク">¶</a></h4>
<dl class="flag">
<dt id="coq:flag.printing-synth">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Printing</span> <span>Synth</span></span></code><a class="headerlink" href="#coq:flag.printing-synth" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>In most of the cases, the type of the result of a matched term is
mechanically synthesizable. Especially, if the result type does not
depend of the matched term. When this option is on (default),
the result type is not printed when <span class="smallcaps">Coq</span> knows that it can re-
synthesize it.</p>
</dd></dl>

</div>
<div class="section" id="printing-matching-on-irrefutable-patterns">
<h4>Printing matching on irrefutable patterns<a class="headerlink" href="#printing-matching-on-irrefutable-patterns" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>If an inductive type has just one constructor, pattern matching can be
written using the first destructuring let syntax.</p>
<dl class="table">
<dt id="coq:table.printing-let">
<em class="property"><span class="sigannot">Table</span></em> <code class="sig-name descname"><span class="notation"><span>Printing</span> <span>Let</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span></code><a class="headerlink" href="#coq:table.printing-let" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Specifies a set of qualids for which pattern matching is displayed using a let expression.
Note that this only applies to pattern matching instances entered with <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span></code>.
It doesn't affect pattern matching explicitly entered with a destructuring
<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">let</span></span></code>.
Use the <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.add-table" title="Add &#64;table"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Add</span> <span class="pre">&#64;table</span></code></a> and <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.remove-table" title="Remove &#64;table"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Remove</span> <span class="pre">&#64;table</span></code></a> commands to update this set.</p>
</dd></dl>

</div>
<div class="section" id="printing-matching-on-booleans">
<h4>Printing matching on booleans<a class="headerlink" href="#printing-matching-on-booleans" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>If an inductive type is isomorphic to the boolean type, pattern matching
can be written using <code class="docutils literal notranslate"><span class="pre">if</span></code> … <code class="docutils literal notranslate"><span class="pre">then</span></code> … <code class="docutils literal notranslate"><span class="pre">else</span></code> ….  This table controls
which types are written this way:</p>
<dl class="table">
<dt id="coq:table.printing-if">
<em class="property"><span class="sigannot">Table</span></em> <code class="sig-name descname"><span class="notation"><span>Printing</span> <span>If</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span></code><a class="headerlink" href="#coq:table.printing-if" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Specifies a set of qualids for which pattern matching is displayed using
<code class="docutils literal notranslate"><span class="pre">if</span></code> … <code class="docutils literal notranslate"><span class="pre">then</span></code> … <code class="docutils literal notranslate"><span class="pre">else</span></code> ….  Use the <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.add-table" title="Add &#64;table"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Add</span> <span class="pre">&#64;table</span></code></a> and <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.remove-table" title="Remove &#64;table"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Remove</span> <span class="pre">&#64;table</span></code></a>
commands to update this set.</p>
</dd></dl>

<p>This example emphasizes what the printing options offer.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">snd</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) (</span><span class="coqdoc-var">H</span><span>:</span><span class="coqdoc-var">A</span><span> * </span><span class="coqdoc-var">B</span><span>) := </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">H</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">pair</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> =&gt; </span><span class="coqdoc-var">y</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt><dd><span>snd is defined</span></dd>
<dt><span class="coqdoc-var">Test</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Let</span><span> </span><span class="coqdoc-keyword">for</span><span> </span><span class="coqdoc-var">prod</span><span>.</span></dt><dd><span>Cases on elements of prod are printed using a `let' form</span></dd>
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">snd</span><span>.</span></dt><dd><span>snd = 
</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (A B : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">B</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">let</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (_, y) := </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">H</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative"> in</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> A B : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">B</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">B</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

Argument scopes are [type_scope type_scope _]</span></dd>
<dt><span class="coqdoc-var">Remove</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Let</span><span> </span><span class="coqdoc-var">prod</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-var">Synth</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-var">Wildcard</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">snd</span><span>.</span></dt><dd><span>snd = 
</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (A B : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">B</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">match</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">H</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">return</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">B</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">with</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
                               | </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">(</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
                               </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">end</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> A B : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">B</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">B</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

Argument scopes are [type_scope type_scope _]</span></dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="advanced-recursive-functions">
<span id="id3"></span><h2>高度な再帰関数<a class="headerlink" href="#advanced-recursive-functions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下の実験的なコマンドは <code class="docutils literal notranslate"><span class="pre">FunInd</span></code> ライブラリが <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">FunInd</span></code> によってロードされたときに有効になります:</p>
<dl class="cmd">
<dt id="coq:cmd.function">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Function</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="gallina-specification-language.html#grammar-token-binder"><span class="hole">binder</span></a></span><span class="notation-sup">*</span></span> <span class="curlies">{ <span class="hole">decrease_annot</span> }</span> <span>:</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a> <span>:=</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:cmd.function" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>このコマンドは <code class="docutils literal notranslate"><span class="pre">Fixpoint</span></code> の一般化と見なすことができます。それは実際には関数 <em>と他の便利な関連オブジェクト</em> を定義するいくつかの方法のラッパーであり、具体的には: その関数の再帰構造を反映する帰納法の原理 (<a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.function-induction" title="function induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">function</span> <span class="pre">induction</span></code></a> 参照) とその不動点等式です。この定義の意味は関数 ident を定義することで、<code class="docutils literal notranslate"><span class="pre">Fixpoint</span></code> に似ています。<code class="docutils literal notranslate"><span class="pre">Fixpoint</span></code> のように、(関数が再帰していないときでさえ) 減少する引数を与えなければいけません、しかしそれが <em>構造的に</em> 減少している必要はありません。{} 注釈のポイントは減少する引数に名前をつけること <em>そして</em> 再帰呼び出しの停止性を保証するためにどの種類の減少基準を使うべきなのかを説明することです。</p>
<p><code class="docutils literal notranslate"><span class="pre">Function</span></code> による構成はさらに <code class="docutils literal notranslate"><span class="pre">with</span></code> 拡張により相互再帰定義を定義することもできます。しかし、この帰納は非-構造的再帰関数については動きません。</p>
<p>どのように帰納法の原理を使って簡単にその関数について論じるかについては関数的帰納法 (<a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.function-induction" title="function induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">function</span> <span class="pre">induction</span></code></a>) と <code class="docutils literal notranslate"><span class="pre">Functional</span> <span class="pre">Scheme</span></code> (<a class="reference internal" href="../user-extensions/proof-schemes.html#functional-scheme"><span class="std std-ref">Generation of induction principles with Functional Scheme</span></a>) のドキュメントを見てください。</p>
<p>注意: 正しい原理を得るには、第一引数として関数の固定されたパラメータを与えるのがより良いでしょう。例えば plus はこのように定義した方が:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">FunInd</span><span>.</span></dt><dd class="coqtop-hidden"><span>[Loading ML file extraction_plugin.cmxs ... done]
[Loading ML file recdef_plugin.cmxs ... done]</span></dd>
</dl>
<span></span><dl>
<dt><span class="coqdoc-keyword">Function</span><span> </span><span class="coqdoc-var">plus</span><span> (</span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span> : </span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">n</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">with</span><span>
| 0 =&gt; </span><span class="coqdoc-var">m</span><span>
| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">p</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt><dd><span>plus is defined
plus is recursively defined (decreasing on 2nd argument)
plus_equation is defined
plus_ind is defined
plus_rec is defined
plus_rect is defined
R_plus_correct is defined
R_plus_complete is defined</span></dd>
</dl>
</div>
<p>これより良いでしょう:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span class="coqdoc-keyword">Function</span><span> </span><span class="coqdoc-var">plus</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> : </span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">n</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">with</span><span>
| 0 =&gt; </span><span class="coqdoc-var">m</span><span>
| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">m</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt><dd><span>plus is defined
plus is recursively defined (decreasing on 1st argument)
plus_equation is defined
plus_ind is defined
plus_rec is defined
plus_rect is defined
R_plus_correct is defined
R_plus_complete is defined</span></dd>
</dl>
</div>
<p><em>制限</em></p>
<p><cite>term</cite><span class="math notranslate nohighlight">\(_{0}\)</span> は 各ブランチの <em>末尾</em> のみで適用される <em>純粋パターンマッチングツリー</em> (<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span> <span class="error"><span class="pre">…</span></span> <span class="keyword"><span class="pre">with</span></span></code>) として構築されなければなりません。</p>
<p>Function は定義された関数の部分適用はサポートしません。従って、以下の例は <cite>wrong</cite> のボディー内の <cite>wrong</cite> の部分適用の存在のため受け入れられません:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Function</span><span> </span><span class="coqdoc-var">wrong</span><span> (</span><span class="coqdoc-var">C</span><span>:</span><span class="coqdoc-var">nat</span><span>) : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-var">List.hd</span><span> 0 (</span><span class="coqdoc-var">List.map</span><span> </span><span class="coqdoc-var">wrong</span><span> (</span><span class="coqdoc-var">C</span><span>::</span><span class="coqdoc-var">nil</span><span>)).</span></dt><dd><span>The command has indeed failed with message:
The reference List.hd was not found in the current environment.</span></dd>
</dl>
</div>
<p>今のところ、依存ケースは非-構造的停止関数として扱われません。</p>
<dl class="exn">
<dt id="coq:exn.the-recursive-argument-must-be-specified">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>The</span> <span>recursive</span> <span>argument</span> <span>must</span> <span>be</span> <span>specified.</span></span></code><a class="headerlink" href="#coq:exn.the-recursive-argument-must-be-specified" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="exn">
<dt id="coq:exn.no-argument-name-ident">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>No</span> <span>argument</span> <span>name</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a><span>.</span></span></code><a class="headerlink" href="#coq:exn.no-argument-name-ident" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="exn">
<dt id="coq:exn.cannot-use-mutual-definition-with-well-founded-recursion-or-measure">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Cannot</span> <span>use</span> <span>mutual</span> <span>definition</span> <span>with</span> <span>well-founded</span> <span>recursion</span> <span>or</span> <span>measure.</span></span></code><a class="headerlink" href="#coq:exn.cannot-use-mutual-definition-with-well-founded-recursion-or-measure" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="warn">
<dt id="coq:warn.cannot-define-graph-for-ident">
<em class="property"><span class="sigannot">Warning</span></em> <code class="sig-name descname"><span class="notation"><span>Cannot</span> <span>define</span> <span>graph</span> <span>for</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a><span>.</span></span></code><a class="headerlink" href="#coq:warn.cannot-define-graph-for-ident" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ident の帰納法の原理を算出するのに使われるグラフ関係 (<cite>R_ident</cite>) の生成は型付けエラーを発生します。<cite>ident</cite> のみが定義され、帰納スキームは生成されません。このエラーは一般的に起こります:</p>
<ul class="simple">
<li><p>その定義は依存型上のパターンマッチを使っており、<code class="docutils literal notranslate"><span class="pre">Function</span></code> はまだそれを扱うことができません。</p></li>
<li><p>その定義は上で説明したような <em>パターンマッチングツリー</em> ではありません。</p></li>
</ul>
</dd></dl>

<dl class="warn">
<dt id="coq:warn.cannot-define-principle-s-for-ident">
<em class="property"><span class="sigannot">Warning</span></em> <code class="sig-name descname"><span class="notation"><span>Cannot</span> <span>define</span> <span>principle(s)</span> <span>for</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a><span>.</span></span></code><a class="headerlink" href="#coq:warn.cannot-define-principle-s-for-ident" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>グラフ関係 (<cite>R_ident</cite>) の生成は成功したが、その帰納法の原理は構築できません。<cite>ident</cite> だけが定義されました。報告してください。</p>
</dd></dl>

<dl class="warn">
<dt id="coq:warn.cannot-build-functional-inversion-principle">
<em class="property"><span class="sigannot">Warning</span></em> <code class="sig-name descname"><span class="notation"><span>Cannot</span> <span>build</span> <span>functional</span> <span>inversion</span> <span>principle.</span></span></code><a class="headerlink" href="#coq:warn.cannot-build-functional-inversion-principle" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>その関数についての <cite>functional inversion</cite> が使えるようになりません。</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">参考</p>
<p><a class="reference internal" href="../user-extensions/proof-schemes.html#functional-scheme"><span class="std std-ref">Generation of induction principles with Functional Scheme</span></a> と <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.function-induction" title="function induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">function</span> <span class="pre">induction</span></code></a></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">{…}</span></code> という注釈に依存して、<code class="docutils literal notranslate"><span class="pre">Function</span></code> によって異なる定義機構が使われます。より詳細な説明を以下で与えます。</p>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Function</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="gallina-specification-language.html#grammar-token-binder"><span class="hole">binder</span></a></span><span class="notation-sup">*</span></span> <span>:</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a> <span>:=</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>非-再帰関数 <cite>ident</cite> をあたかも <cite>Definition</cite> によって定義されたかのように定義します。さらに以下のものが定義されます。</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>ident_rect</cite> と <cite>ident_rec</cite> と <cite>ident_ind</cite> は <cite>term</cite> (<a class="reference internal" href="gallina-specification-language.html#coq:cmd.inductive" title="Inductive"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Inductive</span></code></a> 参照) のパターンマッチ構造を反映します;</p></li>
<li><p>帰納的 <cite>R_ident</cite> は (暗黙に) <cite>ident</cite> のグラフに対応します。</p></li>
<li><p><cite>ident_complete</cite> と <cite>ident_correct</cite> は関数とそのグラフを紐付ける反転情報です。</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Function</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="gallina-specification-language.html#grammar-token-binder"><span class="hole">binder</span></a></span><span class="notation-sup">*</span></span> <span class="curlies">{ <span>struct</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> }</span> <span>:</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a> <span>:=</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>構造的再帰関数 <cite>ident</cite> を <code class="docutils literal notranslate"><span class="pre">Fixpoint</span></code> により定義されたかのように定義します。さらに以下のものが定義されます。</p>
<blockquote>
<div><ul class="simple">
<li><p>上と同じオブジェクト。</p></li>
<li><p><cite>ident</cite>: <cite>ident_equation</cite> という形の不動点方程式。</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Function</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="gallina-specification-language.html#grammar-token-binder"><span class="hole">binder</span></a></span><span class="notation-sup">*</span></span> <span class="curlies">{ <span>measure</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> }</span> <span>:</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a> <span>:=</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Function</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="gallina-specification-language.html#grammar-token-binder"><span class="hole">binder</span></a></span><span class="notation-sup">*</span></span> <span class="curlies">{ <span>wf</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> }</span> <span>:</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a> <span>:=</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>整礎再帰によって再帰関数を定義します。この機能を使うには標準ライブラリの <code class="docutils literal notranslate"><span class="pre">Recdef</span></code> モジュールがロードされていないといけません。<code class="docutils literal notranslate"><span class="pre">{}</span></code> の注釈は強制であり、以下のうちの一つでないといけません。</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">{measure</span></code> <cite>term</cite> <cite>ident</cite> <code class="docutils literal notranslate"><span class="pre">}</span></code> ここで <cite>ident</cite> は減少する引数であり、<cite>term</cite> は <cite>ident</cite> の型から <code class="docutils literal notranslate"><span class="pre">nat</span></code> への関数であり、その減少引数上の値は <cite>term</cite> の再帰呼び出し毎に減少します (<code class="docutils literal notranslate"><span class="pre">nat</span></code> 上なら <code class="docutils literal notranslate"><span class="pre">lt</span></code> 順序に沿って)。関数のパラメータは <cite>term</cite>中で抑えられます;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">{wf</span></code> <cite>term</cite> <cite>ident</cite> <code class="docutils literal notranslate"><span class="pre">}</span></code> ここで <cite>ident</cite> は減少する引数であり、<cite>term</cite> は <cite>ident</cite> の型上の順序関係 (i.e. <cite>T</cite><span class="math notranslate nohighlight">\(_{\sf ident}\)</span> → <cite>T</cite><span class="math notranslate nohighlight">\(_{\sf ident}\)</span> → <code class="docutils literal notranslate"><span class="pre">Prop</span></code> という型) であり、その減少引数は <cite>term</cite> の再帰呼び出し毎に減少します。その順序は整礎でなければなりません。その関数のパラメータは <cite>term</cite> 中で抑えられます。</p></li>
</ul>
</div></blockquote>
<p>注釈に依存して、その関数を定義するのに使われるいくらかの証明課題はユーザに残されます。これらの証明は: 各再帰呼び出しが実際に与えられた基準に照らして減少することの証明であり、そして (もしその基準が <cite>wf</cite> ならば) その順序関係は整礎である証明です。証明課題が解決されると、以下のオブジェクトが定義されます:</p>
<blockquote>
<div><ul class="simple">
<li><p>struct を用いたときと同じオブジェクト;</p></li>
<li><p>補題 <cite>ident</cite><span class="math notranslate nohighlight">\(_{\sf tcc}\)</span> これは全ての証明課題を集めて一つの性質にします。</p></li>
<li><p>補題 <cite>ident</cite><span class="math notranslate nohighlight">\(_{\sf terminate}\)</span> と <cite>ident</cite><span class="math notranslate nohighlight">\(_{\sf F}\)</span> これは indent のエクストラクションをする間にインライン化するために必要となります。</p></li>
</ul>
</div></blockquote>
<p>この方法により再帰関数が定義される方法は、一方で Yves Bertot と Antonia Balaa による、もう一方で Gilles Barthe、Julien Forest、David Pichardie、Vlad Rusu によるいくつかの論文の主題です。注意: 証明課題は補題 <cite>ident</cite><span class="math notranslate nohighlight">\(_{\sf tcc}\)</span> に付随するいくつかのサブゴールとして提示されます。</p>
</dd></dl>

</div>
<div class="section" id="section-mechanism">
<span id="id4"></span><h2>Section mechanism<a class="headerlink" href="#section-mechanism" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The sectioning mechanism can be used to to organize a proof in
structured sections. Then local declarations become available (see
Section <a class="reference internal" href="gallina-specification-language.html#gallina-definitions"><span class="std std-ref">Definitions</span></a>).</p>
<dl class="cmd">
<dt id="coq:cmd.section">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Section</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:cmd.section" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command is used to open a section named <cite>ident</cite>.</p>
</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.end">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>End</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:cmd.end" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command closes the section named <cite>ident</cite>. After closing of the
section, the local declarations (variables and local definitions) get
<em>discharged</em>, meaning that they stop being visible and that all global
objects defined in the section are generalized with respect to the
variables and local definitions they each depended on in the section.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">s1</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Variables</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">nat</span><span>.</span></dt><dd><span>x is declared
y is declared</span></dd>
<dt><span class="coqdoc-keyword">Let</span><span> </span><span class="coqdoc-var">y'</span><span> := </span><span class="coqdoc-var">y</span><span>.</span></dt><dd><span>y' is defined</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">x'</span><span> := </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">x</span><span>.</span></dt><dd><span>x' is defined</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">x''</span><span> := </span><span class="coqdoc-var">x'</span><span> + </span><span class="coqdoc-var">y'</span><span>.</span></dt><dd><span>x'' is defined</span></dd>
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">x'</span><span>.</span></dt><dd><span>x' = </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
<dt><span class="coqdoc-keyword">End</span><span> </span><span class="coqdoc-var">s1</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">x'</span><span>.</span></dt><dd><span>x' = </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

Argument scope is [nat_scope]</span></dd>
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">x''</span><span>.</span></dt><dd><span>x'' = </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">let</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> y' := </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">in</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x'</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y'</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

Argument scopes are [nat_scope nat_scope]</span></dd>
</dl>
</div>
</div>
<p>Notice the difference between the value of <cite>x’</cite> and <cite>x’’</cite> inside section
<cite>s1</cite> and outside.</p>
<dl class="exn">
<dt id="coq:exn.this-is-not-the-last-opened-section">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>This</span> <span>is</span> <span>not</span> <span>the</span> <span>last</span> <span>opened</span> <span>section.</span></span></code><a class="headerlink" href="#coq:exn.this-is-not-the-last-opened-section" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<p><strong>Remarks:</strong></p>
<ol class="arabic simple">
<li><p>Most commands, like <code class="docutils literal notranslate"><span class="pre">Hint</span></code>, <code class="docutils literal notranslate"><span class="pre">Notation</span></code>, option management, … which
appear inside a section are canceled when the section is closed.</p></li>
</ol>
</div>
<div class="section" id="module-system">
<h2>Module system<a class="headerlink" href="#module-system" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The module system provides a way of packaging related elements
together, as well as a means of massive abstraction.</p>
<blockquote>
<div><pre>
<strong id="grammar-token-module-type">module_type      </strong> ::=  qualid
                       | <a class="reference internal" href="#grammar-token-module-type"><code class="xref docutils literal notranslate"><span class="pre">module_type</span></code></a> with Definition qualid := term
                       | <a class="reference internal" href="#grammar-token-module-type"><code class="xref docutils literal notranslate"><span class="pre">module_type</span></code></a> with Module qualid := qualid
                       | qualid qualid … qualid
                       | !qualid qualid … qualid
<strong id="grammar-token-module-binding">module_binding   </strong> ::=  ( [Import|Export] ident … ident : module_type )
<strong id="grammar-token-module-bindings">module_bindings  </strong> ::=  <a class="reference internal" href="#grammar-token-module-binding"><code class="xref docutils literal notranslate"><span class="pre">module_binding</span></code></a> … <a class="reference internal" href="#grammar-token-module-binding"><code class="xref docutils literal notranslate"><span class="pre">module_binding</span></code></a>
<strong id="grammar-token-module-expression">module_expression</strong> ::=  qualid … qualid
                       | !qualid … qualid
</pre>
<p>Syntax of modules</p>
</div></blockquote>
<p>In the syntax of module application, the ! prefix indicates that any
<cite>Inline</cite> directive in the type of the functor arguments will be ignored
(see the <code class="docutils literal notranslate"><span class="pre">Module</span> <span class="pre">Type</span></code> command below).</p>
<dl class="cmd">
<dt id="coq:cmd.module">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Module</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:cmd.module" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command is used to start an interactive module named <cite>ident</cite>.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Module</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-module-binding"><span class="hole">module_binding</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>Starts an interactive functor with
parameters given by module_bindings.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Module</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-module-type"><span class="hole">module_type</span></a></span></code></dt>
<dd><p>Starts an interactive module specifying its module type.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Module</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-module-binding"><span class="hole">module_binding</span></a></span><span class="notation-sup">*</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-module-type"><span class="hole">module_type</span></a></span></code></dt>
<dd><p>Starts an interactive functor with parameters given by the list of <cite>module binding</cite>, and output module
type <cite>module_type</cite>.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Module</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>&lt;:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-module-type"><span class="hole">module_type</span></a></span><span class="notation-sup">+</span><span class="notation-sub">&lt;:</span></span></span></code></dt>
<dd><blockquote>
<div><p>Starts an interactive module satisfying each <cite>module_type</cite>.</p>
</div></blockquote>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Module</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-module-binding"><span class="hole">module_binding</span></a></span><span class="notation-sup">*</span></span> <span>&lt;:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-module-type"><span class="hole">module_type</span></a></span><span class="notation-sup">+</span><span class="notation-sub">&lt;:</span></span><span>.</span></span></code></dt>
<dd><p>Starts an interactive functor with parameters given by the list of <cite>module_binding</cite>. The output module type
is verified against each <cite>module_type</cite>.</p>
</dd></dl>

</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Module</span> <span>[</span> <span>Import</span> <span>|</span> <span>Export</span> <span>]</span></span></code></dt>
<dd><p>Behaves like <code class="docutils literal notranslate"><span class="pre">Module</span></code>, but automatically imports or exports the module.</p>
</dd></dl>

<div class="section" id="reserved-commands-inside-an-interactive-module">
<h3>Reserved commands inside an interactive module<a class="headerlink" href="#reserved-commands-inside-an-interactive-module" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="cmd">
<dt id="coq:cmd.include">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Include</span> <span class="hole">module</span></span></code><a class="headerlink" href="#coq:cmd.include" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Includes the content of module in the current
interactive module. Here module can be a module expression or a module
type expression. If module is a high-order module or module type
expression then the system tries to instantiate module by the current
interactive module.</p>
</dd></dl>

<dl class="cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Include</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">module</span></span><span class="notation-sup">+</span><span class="notation-sub">&lt;+</span></span></span></code></dt>
<dd><p>is a shortcut for the commands <code class="docutils literal notranslate"><span class="pre">Include</span></code> <cite>module</cite> for each <cite>module</cite>.</p>
</dd></dl>

<dl class="cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>End</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd><p>This command closes the interactive module <cite>ident</cite>. If the module type
was given the content of the module is matched against it and an error
is signaled if the matching fails. If the module is basic (is not a
functor) its components (constants, inductive types, submodules etc.)
are now available through the dot notation.</p>
<blockquote>
<div><dl class="exn">
<dt id="coq:exn.no-such-label-ident">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>No</span> <span>such</span> <span>label</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a><span>.</span></span></code><a class="headerlink" href="#coq:exn.no-such-label-ident" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="exn">
<dt id="coq:exn.signature-components-for-label-ident-do-not-match">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Signature</span> <span>components</span> <span>for</span> <span>label</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>do</span> <span>not</span> <span>match.</span></span></code><a class="headerlink" href="#coq:exn.signature-components-for-label-ident-do-not-match" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="exn">
<dt id="coq:exn.this-is-not-the-last-opened-module">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>This</span> <span>is</span> <span>not</span> <span>the</span> <span>last</span> <span>opened</span> <span>module.</span></span></code><a class="headerlink" href="#coq:exn.this-is-not-the-last-opened-module" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</div></blockquote>
</dd></dl>

<dl class="cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Module</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>:=</span> <a class="reference internal" href="#grammar-token-module-expression"><span class="hole">module_expression</span></a></span></code></dt>
<dd><p>This command defines the module identifier <cite>ident</cite> to be equal
to <cite>module_expression</cite>.</p>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Module</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-module-binding"><span class="hole">module_binding</span></a></span><span class="notation-sup">*</span></span> <span>:=</span> <a class="reference internal" href="#grammar-token-module-expression"><span class="hole">module_expression</span></a></span></code></dt>
<dd><p>Defines a functor with parameters given by the list of <cite>module_binding</cite> and body <cite>module_expression</cite>.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Module</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-module-binding"><span class="hole">module_binding</span></a></span><span class="notation-sup">*</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-module-type"><span class="hole">module_type</span></a> <span>:=</span> <a class="reference internal" href="#grammar-token-module-expression"><span class="hole">module_expression</span></a></span></code></dt>
<dd><p>Defines a functor with parameters given by the list of <cite>module_binding</cite> (possibly none), and output module type <cite>module_type</cite>,
with body <cite>module_expression</cite>.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Module</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-module-binding"><span class="hole">module_binding</span></a></span><span class="notation-sup">*</span></span> <span>&lt;:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-module-type"><span class="hole">module_type</span></a></span><span class="notation-sup">+</span><span class="notation-sub">&lt;:</span></span> <span>:=</span> <a class="reference internal" href="#grammar-token-module-expression"><span class="hole">module_expression</span></a></span></code></dt>
<dd><p>Defines a functor with parameters given by module_bindings (possibly none) with body <cite>module_expression</cite>.
The body is checked against each <cite>module_type</cite><span class="math notranslate nohighlight">\(_{i}\)</span>.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Module</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-module-binding"><span class="hole">module_binding</span></a></span><span class="notation-sup">*</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-module-expression"><span class="hole">module_expression</span></a></span><span class="notation-sup">+</span><span class="notation-sub">&lt;+</span></span></span></code></dt>
<dd><p>is equivalent to an interactive module where each <cite>module_expression</cite> is included.</p>
</dd></dl>

</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.module-type">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Module</span> <span>Type</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:cmd.module-type" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>This command is used to start an interactive module type <cite>ident</cite>.</p>
<blockquote>
<div><dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Module</span> <span>Type</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-module-binding"><span class="hole">module_binding</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>Starts an interactive functor type with parameters given by <cite>module_bindings</cite>.</p>
</dd></dl>

</div></blockquote>
</div>
<div class="section" id="reserved-commands-inside-an-interactive-module-type">
<h3>Reserved commands inside an interactive module type:<a class="headerlink" href="#reserved-commands-inside-an-interactive-module-type" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Include</span> <span class="hole">module</span></span></code></dt>
<dd><p>Same as <code class="docutils literal notranslate"><span class="pre">Include</span></code> inside a module.</p>
</dd></dl>

<dl class="cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Include</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">module</span></span><span class="notation-sup">+</span><span class="notation-sub">&lt;+</span></span></span></code></dt>
<dd><p>is a shortcut for the command <code class="docutils literal notranslate"><span class="pre">Include</span></code> <cite>module</cite> for each <cite>module</cite>.</p>
</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.inline">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><a class="reference internal" href="gallina-specification-language.html#grammar-token-assumption-keyword"><span class="hole">assumption_keyword</span></a> <span>Inline</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-assums"><span class="hole">assums</span></a></span></code><a class="headerlink" href="#coq:cmd.inline" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The instance of this assumption will be automatically expanded at functor application, except when
this functor application is prefixed by a <code class="docutils literal notranslate"><span class="pre">!</span></code> annotation.</p>
</dd></dl>

<dl class="cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>End</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd><p>This command closes the interactive module type <cite>ident</cite>.</p>
<dl class="exn">
<dt id="coq:exn.this-is-not-the-last-opened-module-type">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>This</span> <span>is</span> <span>not</span> <span>the</span> <span>last</span> <span>opened</span> <span>module</span> <span>type.</span></span></code><a class="headerlink" href="#coq:exn.this-is-not-the-last-opened-module-type" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Module</span> <span>Type</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>:=</span> <a class="reference internal" href="#grammar-token-module-type"><span class="hole">module_type</span></a></span></code></dt>
<dd><p>Defines a module type <cite>ident</cite> equal to <cite>module_type</cite>.</p>
<blockquote>
<div><dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Module</span> <span>Type</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-module-binding"><span class="hole">module_binding</span></a></span><span class="notation-sup">*</span></span> <span>:=</span> <a class="reference internal" href="#grammar-token-module-type"><span class="hole">module_type</span></a></span></code></dt>
<dd><p>Defines a functor type <cite>ident</cite> specifying functors taking arguments <cite>module_bindings</cite> and
returning <cite>module_type</cite>.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Module</span> <span>Type</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-module-binding"><span class="hole">module_binding</span></a></span><span class="notation-sup">*</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-module-type"><span class="hole">module_type</span></a></span><span class="notation-sup">+</span><span class="notation-sub">&lt;+</span></span></span></code></dt>
<dd><p>is equivalent to an interactive module type were each <cite>module_type</cite> is included.</p>
</dd></dl>

</div></blockquote>
</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.declare-module">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Declare</span> <span>Module</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-module-type"><span class="hole">module_type</span></a></span></code><a class="headerlink" href="#coq:cmd.declare-module" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Declares a module <cite>ident</cite> of type <cite>module_type</cite>.</p>
<blockquote>
<div><dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Declare</span> <span>Module</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-module-binding"><span class="hole">module_binding</span></a></span><span class="notation-sup">*</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-module-type"><span class="hole">module_type</span></a></span></code></dt>
<dd><p>Declares a functor with parameters given by the list of <cite>module_binding</cite> and output module type
<cite>module_type</cite>.</p>
</dd></dl>

</div></blockquote>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<p>Let us define a simple module.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Module</span><span> </span><span class="coqdoc-var">M</span><span>.</span></dt><dd><span>Interactive Module M started</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">T</span><span> := </span><span class="coqdoc-var">nat</span><span>.</span></dt><dd><span>T is defined</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">x</span><span> := 0.</span></dt><dd><span>x is defined</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">bool</span><span>.</span></dt><dd><span>1 subgoal
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
<dt><span class="coqdoc-tactic">exact</span><span> </span><span class="coqdoc-var">true</span><span>.</span></dt><dd><span>No more subgoals.</span></dd>
<dt><span class="coqdoc-keyword">Defined</span><span>.</span></dt><dd><span>y is defined</span></dd>
<dt><span class="coqdoc-keyword">End</span><span> </span><span class="coqdoc-var">M</span><span>.</span></dt><dd><span>Module M is defined</span></dd>
</dl>
</div>
</div>
<p>Inside a module one can define constants, prove theorems and do any
other things that can be done in the toplevel. Components of a closed
module can be accessed using the dot notation:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">M.x</span><span>.</span></dt><dd><span>M.x = 0
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
</dl>
</div>
<p>A simple module type:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Module</span><span> </span><span class="coqdoc-keyword">Type</span><span> </span><span class="coqdoc-var">SIG</span><span>.</span></dt><dd><span>Interactive Module Type SIG started</span></dd>
<dt><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">T</span><span> : </span><span class="coqdoc-keyword">Set</span><span>.</span></dt><dd><span>T is declared</span></dd>
<dt><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">T</span><span>.</span></dt><dd><span>x is declared</span></dd>
<dt><span class="coqdoc-keyword">End</span><span> </span><span class="coqdoc-var">SIG</span><span>.</span></dt><dd><span>Module Type SIG is defined</span></dd>
</dl>
</div>
<p>Now we can create a new module from M, giving it a less precise
specification: the y component is dropped as well as the body of x.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Module</span><span> </span><span class="coqdoc-var">N</span><span> : </span><span class="coqdoc-var">SIG</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">T</span><span> := </span><span class="coqdoc-var">nat</span><span> := </span><span class="coqdoc-var">M</span><span>.</span></dt><dd><span>Module N is defined</span></dd>
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">N.T</span><span>.</span></dt><dd><span>N.T = </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">N.x</span><span>.</span></dt><dd><span>*** [ N.x : </span><span class="ansi-fg-light-magenta ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">N</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">T</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> ]</span></dd>
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">N.y</span><span>.</span></dt><dd><span>The command has indeed failed with message:
N.y not a defined object.</span></dd>
</dl>
</div>
<div class="coqtop literal-block coqtop-hidden docutils container">
<span class="coqtop-reset"></span><dl>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Module</span><span> </span><span class="coqdoc-var">M</span><span>.</span></dt><dd class="coqtop-hidden"><span>Interactive Module M started</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">T</span><span> := </span><span class="coqdoc-var">nat</span><span>.</span></dt><dd class="coqtop-hidden"><span>T is defined</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">x</span><span> := 0.</span></dt><dd class="coqtop-hidden"><span>x is defined</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">bool</span><span>.</span></dt><dd class="coqtop-hidden"><span>1 subgoal
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-tactic">exact</span><span> </span><span class="coqdoc-var">true</span><span>.</span></dt><dd class="coqtop-hidden"><span>No more subgoals.</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Defined</span><span>.</span></dt><dd class="coqtop-hidden"><span>y is defined</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">End</span><span> </span><span class="coqdoc-var">M</span><span>.</span></dt><dd class="coqtop-hidden"><span>Module M is defined</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Module</span><span> </span><span class="coqdoc-keyword">Type</span><span> </span><span class="coqdoc-var">SIG</span><span>.</span></dt><dd class="coqtop-hidden"><span>Interactive Module Type SIG started</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">T</span><span> : </span><span class="coqdoc-keyword">Set</span><span>.</span></dt><dd class="coqtop-hidden"><span>T is declared</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">T</span><span>.</span></dt><dd class="coqtop-hidden"><span>x is declared</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">End</span><span> </span><span class="coqdoc-var">SIG</span><span>.</span></dt><dd class="coqtop-hidden"><span>Module Type SIG is defined</span></dd>
</dl>
</div>
<p>The definition of <code class="docutils literal notranslate"><span class="pre">N</span></code> using the module type expression <code class="docutils literal notranslate"><span class="pre">SIG</span></code> with
<code class="docutils literal notranslate"><span class="pre">Definition</span> <span class="pre">T</span> <span class="pre">:=</span> <span class="pre">nat</span></code> is equivalent to the following one:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Module</span><span> </span><span class="coqdoc-keyword">Type</span><span> </span><span class="coqdoc-var">SIG'</span><span>.</span></dt><dd><span>Interactive Module Type SIG' started</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">T</span><span> : </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-var">nat</span><span>.</span></dt><dd><span>T is defined</span></dd>
<dt><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">T</span><span>.</span></dt><dd><span>x is declared</span></dd>
<dt><span class="coqdoc-keyword">End</span><span> </span><span class="coqdoc-var">SIG'</span><span>.</span></dt><dd><span>Module Type SIG' is defined</span></dd>
<dt><span class="coqdoc-keyword">Module</span><span> </span><span class="coqdoc-var">N</span><span> : </span><span class="coqdoc-var">SIG'</span><span> := </span><span class="coqdoc-var">M</span><span>.</span></dt><dd><span>Module N is defined</span></dd>
</dl>
</div>
<p>If we just want to be sure that our implementation satisfies a
given module type without restricting the interface, we can use a
transparent constraint</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Module</span><span> </span><span class="coqdoc-var">P</span><span> &lt;: </span><span class="coqdoc-var">SIG</span><span> := </span><span class="coqdoc-var">M</span><span>.</span></dt><dd><span>Module P is defined</span></dd>
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">P.y</span><span>.</span></dt><dd><span>P.y = </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">true</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
</dl>
</div>
<p>Now let us create a functor, i.e. a parametric module</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Module</span><span> </span><span class="coqdoc-var">Two</span><span> (</span><span class="coqdoc-var">X</span><span> </span><span class="coqdoc-var">Y</span><span>: </span><span class="coqdoc-var">SIG</span><span>).</span></dt><dd><span>Interactive Module Two started</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">T</span><span> := (</span><span class="coqdoc-var">X.T</span><span> * </span><span class="coqdoc-var">Y.T</span><span>)%</span><span class="coqdoc-keyword">type</span><span>.</span></dt><dd><span>T is defined</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">x</span><span> := (</span><span class="coqdoc-var">X.x</span><span>, </span><span class="coqdoc-var">Y.x</span><span>).</span></dt><dd><span>x is defined</span></dd>
<dt><span class="coqdoc-keyword">End</span><span> </span><span class="coqdoc-var">Two</span><span>.</span></dt><dd><span>Module Two is defined</span></dd>
</dl>
</div>
<p>and apply it to our modules and do some computations:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Module</span><span> </span><span class="coqdoc-var">Q</span><span> := </span><span class="coqdoc-var">Two</span><span> </span><span class="coqdoc-var">M</span><span> </span><span class="coqdoc-var">N</span><span>.</span></dt><dd><span>Module Q is defined</span></dd>
<dt><span class="coqdoc-keyword">Eval</span><span> </span><span class="coqdoc-tactic">compute</span><span> </span><span class="coqdoc-tactic">in</span><span> (</span><span class="coqdoc-var">fst</span><span> </span><span class="coqdoc-var">Q.x</span><span> + </span><span class="coqdoc-var">snd</span><span> </span><span class="coqdoc-var">Q.x</span><span>).</span></dt><dd><span>     = </span><span class="ansi-fg-light-magenta ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">N</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
</dl>
</div>
<p>In the end, let us define a module type with two sub-modules, sharing
some of the fields and give one of its possible implementations:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Module</span><span> </span><span class="coqdoc-keyword">Type</span><span> </span><span class="coqdoc-var">SIG2</span><span>.</span></dt><dd><span>Interactive Module Type SIG2 started</span></dd>
<dt><span class="coqdoc-keyword">Declare Module</span><span> </span><span class="coqdoc-var">M1</span><span> : </span><span class="coqdoc-var">SIG</span><span>.</span></dt><dd><span>Module M1 is declared</span></dd>
<dt><span class="coqdoc-keyword">Module</span><span> </span><span class="coqdoc-var">M2</span><span> &lt;: </span><span class="coqdoc-var">SIG</span><span>.</span></dt><dd><span>Interactive Module M2 started</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">T</span><span> := </span><span class="coqdoc-var">M1.T</span><span>.</span></dt><dd><span>T is defined</span></dd>
<dt><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">T</span><span>.</span></dt><dd><span>x is declared</span></dd>
<dt><span class="coqdoc-keyword">End</span><span> </span><span class="coqdoc-var">M2</span><span>.</span></dt><dd><span>Module M2 is defined</span></dd>
<dt><span class="coqdoc-keyword">End</span><span> </span><span class="coqdoc-var">SIG2</span><span>.</span></dt><dd><span>Module Type SIG2 is defined</span></dd>
<dt><span class="coqdoc-keyword">Module</span><span> </span><span class="coqdoc-var">Mod</span><span> &lt;: </span><span class="coqdoc-var">SIG2</span><span>.</span></dt><dd><span>Interactive Module Mod started</span></dd>
<dt><span class="coqdoc-keyword">Module</span><span> </span><span class="coqdoc-var">M1</span><span>.</span></dt><dd><span>Interactive Module M1 started</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">T</span><span> := </span><span class="coqdoc-var">nat</span><span>.</span></dt><dd><span>T is defined</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">x</span><span> := 1.</span></dt><dd><span>x is defined</span></dd>
<dt><span class="coqdoc-keyword">End</span><span> </span><span class="coqdoc-var">M1</span><span>.</span></dt><dd><span>Module M1 is defined</span></dd>
<dt><span class="coqdoc-keyword">Module</span><span> </span><span class="coqdoc-var">M2</span><span> := </span><span class="coqdoc-var">M</span><span>.</span></dt><dd><span>Module M2 is defined</span></dd>
<dt><span class="coqdoc-keyword">End</span><span> </span><span class="coqdoc-var">Mod</span><span>.</span></dt><dd><span>Module Mod is defined</span></dd>
</dl>
</div>
<p>Notice that <code class="docutils literal notranslate"><span class="pre">M</span></code> is a correct body for the component <code class="docutils literal notranslate"><span class="pre">M2</span></code> since its <code class="docutils literal notranslate"><span class="pre">T</span></code>
component is equal <code class="docutils literal notranslate"><span class="pre">nat</span></code> and hence <code class="docutils literal notranslate"><span class="pre">M1.T</span></code> as specified.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<ol class="arabic simple">
<li><p>Modules and module types can be nested components of each other.</p></li>
<li><p>One can have sections inside a module or a module type, but not a
module or a module type inside a section.</p></li>
<li><p>Commands like <code class="docutils literal notranslate"><span class="pre">Hint</span></code> or <code class="docutils literal notranslate"><span class="pre">Notation</span></code> can also appear inside modules and
module types. Note that in case of a module definition like:</p></li>
</ol>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Module N : SIG := M.
</pre></div>
</div>
<p>or:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Module N : SIG. … End N.
</pre></div>
</div>
<p>hints and the like valid for <code class="docutils literal notranslate"><span class="pre">N</span></code> are not those defined in <code class="docutils literal notranslate"><span class="pre">M</span></code>
(or the module body) but the ones defined in <code class="docutils literal notranslate"><span class="pre">SIG</span></code>.</p>
</div>
<span class="target" id="import-qualid"></span><dl class="cmd">
<dt id="coq:cmd.import">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Import</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span></code><a class="headerlink" href="#coq:cmd.import" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>If <cite>qualid</cite> denotes a valid basic module (i.e. its module type is a
signature), makes its components available by their short names.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span class="coqdoc-keyword">Module</span><span> </span><span class="coqdoc-var">Mod</span><span>.</span></dt><dd><span>Interactive Module Mod started</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">T</span><span>:=</span><span class="coqdoc-var">nat</span><span>.</span></dt><dd><span>T is defined</span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">T</span><span>.</span></dt><dd><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">T</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
<dt><span class="coqdoc-keyword">End</span><span> </span><span class="coqdoc-var">Mod</span><span>.</span></dt><dd><span>Module Mod is defined</span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">Mod.T</span><span>.</span></dt><dd><span class="ansi-fg-light-magenta ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Mod</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">T</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">T</span><span>.</span></dt><dd><span>The command has indeed failed with message:
The reference T was not found in the current environment.</span></dd>
<dt><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">Mod</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">T</span><span>.</span></dt><dd><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">T</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
</dl>
</div>
</div>
<p>Some features defined in modules are activated only when a module is
imported. This is for instance the case of notations (see <a class="reference internal" href="../user-extensions/syntax-extensions.html#notations"><span class="std std-ref">Notations</span></a>).</p>
<p>Declarations made with the <code class="docutils literal notranslate"><span class="pre">Local</span></code> flag are never imported by the <a class="reference internal" href="#coq:cmd.import" title="Import"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Import</span></code></a>
command. Such declarations are only accessible through their fully
qualified name.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Module</span><span> </span><span class="coqdoc-var">A</span><span>.</span></dt><dd><span>Interactive Module A started</span></dd>
<dt><span class="coqdoc-keyword">Module</span><span> </span><span class="coqdoc-var">B</span><span>.</span></dt><dd><span>Interactive Module B started</span></dd>
<dt><span class="coqdoc-keyword">Local</span><span> </span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">T</span><span> := </span><span class="coqdoc-var">nat</span><span>.</span></dt><dd><span>T is defined</span></dd>
<dt><span class="coqdoc-keyword">End</span><span> </span><span class="coqdoc-var">B</span><span>.</span></dt><dd><span>Module B is defined</span></dd>
<dt><span class="coqdoc-keyword">End</span><span> </span><span class="coqdoc-var">A</span><span>.</span></dt><dd><span>Module A is defined</span></dd>
<dt><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">A</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">B.T</span><span>.</span></dt><dd><span>The command has indeed failed with message:
The reference B.T was not found in the current environment.</span></dd>
</dl>
</div>
</div>
<dl class="cmdv">
<dt id="coq:cmdv.export">
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Export</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span></code><a class="headerlink" href="#coq:cmdv.export" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>When the module containing the command Export qualid
is imported, qualid is imported as well.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.qualid-is-not-a-module">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><a class="reference internal" href="gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span>is</span> <span>not</span> <span>a</span> <span>module.</span></span></code><a class="headerlink" href="#coq:exn.qualid-is-not-a-module" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="warn">
<dt id="coq:warn.trying-to-mask-the-absolute-name-qualid">
<em class="property"><span class="sigannot">Warning</span></em> <code class="sig-name descname"><span class="notation"><span>Trying</span> <span>to</span> <span>mask</span> <span>the</span> <span>absolute</span> <span>name</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a><span>!</span></span></code><a class="headerlink" href="#coq:warn.trying-to-mask-the-absolute-name-qualid" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.print-module">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Print</span> <span>Module</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:cmd.print-module" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Prints the module type and (optionally) the body of the module <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.print-module-type">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Print</span> <span>Module</span> <span>Type</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:cmd.print-module-type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Prints the module type corresponding to <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
</dd></dl>

<dl class="flag">
<dt id="coq:flag.short-module-printing">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Short</span> <span>Module</span> <span>Printing</span></span></code><a class="headerlink" href="#coq:flag.short-module-printing" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This option (off by default) disables the printing of the types of fields,
leaving only their names, for the commands <a class="reference internal" href="#coq:cmd.print-module" title="Print Module"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Print</span> <span class="pre">Module</span></code></a> and
<a class="reference internal" href="#coq:cmd.print-module-type" title="Print Module Type"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Print</span> <span class="pre">Module</span> <span class="pre">Type</span></code></a>.</p>
</dd></dl>

</div>
</div>
<div class="section" id="libraries-and-qualified-names">
<h2>Libraries and qualified names<a class="headerlink" href="#libraries-and-qualified-names" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="names-of-libraries">
<span id="id5"></span><h3>Names of libraries<a class="headerlink" href="#names-of-libraries" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The theories developed in <span class="smallcaps">Coq</span> are stored in <em>library files</em> which are
hierarchically classified into <em>libraries</em> and <em>sublibraries</em>. To
express this hierarchy, library names are represented by qualified
identifiers qualid, i.e. as list of identifiers separated by dots (see
<a class="reference internal" href="gallina-specification-language.html#gallina-identifiers"><span class="std std-ref">Qualified identifiers and simple identifiers</span></a>). For instance, the library file <code class="docutils literal notranslate"><span class="pre">Mult</span></code> of the standard
<span class="smallcaps">Coq</span> library <code class="docutils literal notranslate"><span class="pre">Arith</span></code> is named <code class="docutils literal notranslate"><span class="pre">Coq.Arith.Mult</span></code>. The identifier that starts
the name of a library is called a <em>library root</em>. All library files of
the standard library of <span class="smallcaps">Coq</span> have the reserved root <span class="smallcaps">Coq</span> but library
filenames based on other roots can be obtained by using <span class="smallcaps">Coq</span> commands
(coqc, coqtop, coqdep, …) options <code class="docutils literal notranslate"><span class="pre">-Q</span></code> or <code class="docutils literal notranslate"><span class="pre">-R</span></code> (see <a class="reference internal" href="../practical-tools/coq-commands.html#command-line-options"><span class="std std-ref">By command line options</span></a>).
Also, when an interactive <span class="smallcaps">Coq</span> session starts, a library of root <code class="docutils literal notranslate"><span class="pre">Top</span></code> is
started, unless option <code class="docutils literal notranslate"><span class="pre">-top</span></code> or <code class="docutils literal notranslate"><span class="pre">-notop</span></code> is set (see <a class="reference internal" href="../practical-tools/coq-commands.html#command-line-options"><span class="std std-ref">By command line options</span></a>).</p>
</div>
<div class="section" id="qualified-names">
<span id="id6"></span><h3>Qualified names<a class="headerlink" href="#qualified-names" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Library files are modules which possibly contain submodules which
eventually contain constructions (axioms, parameters, definitions,
lemmas, theorems, remarks or facts). The <em>absolute name</em>, or <em>full
name</em>, of a construction in some library file is a qualified
identifier starting with the logical name of the library file,
followed by the sequence of submodules names encapsulating the
construction and ended by the proper name of the construction.
Typically, the absolute name <code class="docutils literal notranslate"><span class="pre">Coq.Init.Logic.eq</span></code> denotes Leibniz’
equality defined in the module Logic in the sublibrary <code class="docutils literal notranslate"><span class="pre">Init</span></code> of the
standard library of <span class="smallcaps">Coq</span>.</p>
<p>The proper name that ends the name of a construction is the short name
(or sometimes base name) of the construction (for instance, the short
name of <code class="docutils literal notranslate"><span class="pre">Coq.Init.Logic.eq</span></code> is <code class="docutils literal notranslate"><span class="pre">eq</span></code>). Any partial suffix of the absolute
name is a <em>partially qualified name</em> (e.g. <code class="docutils literal notranslate"><span class="pre">Logic.eq</span></code> is a partially
qualified name for <code class="docutils literal notranslate"><span class="pre">Coq.Init.Logic.eq</span></code>). Especially, the short name of a
construction is its shortest partially qualified name.</p>
<p><span class="smallcaps">Coq</span> does not accept two constructions (definition, theorem, …) with
the same absolute name but different constructions can have the same
short name (or even same partially qualified names as soon as the full
names are different).</p>
<p>Notice that the notion of absolute, partially qualified and short
names also applies to library filenames.</p>
<p><strong>Visibility</strong></p>
<p><span class="smallcaps">Coq</span> maintains a table called the name table which maps partially qualified
names of constructions to absolute names. This table is updated by the
commands <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.require" title="Require"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Require</span></code></a>, <a class="reference internal" href="#coq:cmd.import" title="Import"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Import</span></code></a> and <a class="reference internal" href="#coq:cmdv.export" title="Export"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Export</span></code></a> and
also each time a new declaration is added to the context. An absolute
name is called visible from a given short or partially qualified name
when this latter name is enough to denote it. This means that the
short or partially qualified name is mapped to the absolute name in
<span class="smallcaps">Coq</span> name table. Definitions flagged as Local are only accessible with
their fully qualified name (see <a class="reference internal" href="gallina-specification-language.html#gallina-definitions"><span class="std std-ref">Definitions</span></a>).</p>
<p>It may happen that a visible name is hidden by the short name or a
qualified name of another construction. In this case, the name that
has been hidden must be referred to using one more level of
qualification. To ensure that a construction always remains
accessible, absolute names can never be hidden.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Check</span><span> 0.</span></dt><dd><span>0
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">nat</span><span> := </span><span class="coqdoc-var">bool</span><span>.</span></dt><dd><span>nat is defined</span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> 0.</span></dt><dd><span>0
     : </span><span class="ansi-fg-light-magenta ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Datatypes</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">Datatypes.nat</span><span>.</span></dt><dd><span class="ansi-fg-light-magenta ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Datatypes</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
<dt><span class="coqdoc-keyword">Locate</span><span> </span><span class="coqdoc-var">nat</span><span>.</span></dt><dd><span>Constant Top.nat
Inductive Coq.Init.Datatypes.nat
  (shorter name to refer to it in current context is Datatypes.nat)</span></dd>
</dl>
</div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参考</p>
<p>Commands <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.locate" title="Locate"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Locate</span></code></a> and <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.locate-library" title="Locate Library"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Locate</span> <span class="pre">Library</span></code></a>.</p>
</div>
</div>
<div class="section" id="libraries-and-filesystem">
<span id="id7"></span><h3>Libraries and filesystem<a class="headerlink" href="#libraries-and-filesystem" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>The questions described here have been subject to redesign in <span class="smallcaps">Coq</span> 8.5.
Former versions of <span class="smallcaps">Coq</span> use the same terminology to describe slightly different things.</p>
</div>
<p>Compiled files (<code class="docutils literal notranslate"><span class="pre">.vo</span></code> and <code class="docutils literal notranslate"><span class="pre">.vio</span></code>) store sub-libraries. In order to refer
to them inside <span class="smallcaps">Coq</span>, a translation from file-system names to <span class="smallcaps">Coq</span> names
is needed. In this translation, names in the file system are called
<em>physical</em> paths while <span class="smallcaps">Coq</span> names are contrastingly called <em>logical</em>
names.</p>
<p>A logical prefix Lib can be associated to a physical pathpath using
the command line option <code class="docutils literal notranslate"><span class="pre">-Q</span></code> <cite>path</cite> <code class="docutils literal notranslate"><span class="pre">Lib</span></code>. All subfolders of path are
recursively associated to the logical path <code class="docutils literal notranslate"><span class="pre">Lib</span></code> extended with the
corresponding suffix coming from the physical path. For instance, the
folder <code class="docutils literal notranslate"><span class="pre">path/fOO/Bar</span></code> maps to <code class="docutils literal notranslate"><span class="pre">Lib.fOO.Bar</span></code>. Subdirectories corresponding
to invalid <span class="smallcaps">Coq</span> identifiers are skipped, and, by convention,
subdirectories named <code class="docutils literal notranslate"><span class="pre">CVS</span></code> or <code class="docutils literal notranslate"><span class="pre">_darcs</span></code> are skipped too.</p>
<p>Thanks to this mechanism, <code class="docutils literal notranslate"><span class="pre">.vo</span></code> files are made available through the
logical name of the folder they are in, extended with their own
basename. For example, the name associated to the file
<code class="docutils literal notranslate"><span class="pre">path/fOO/Bar/File.vo</span></code> is <code class="docutils literal notranslate"><span class="pre">Lib.fOO.Bar.File</span></code>. The same caveat applies for
invalid identifiers. When compiling a source file, the <code class="docutils literal notranslate"><span class="pre">.vo</span></code> file stores
its logical name, so that an error is issued if it is loaded with the
wrong loadpath afterwards.</p>
<p>Some folders have a special status and are automatically put in the
path. <span class="smallcaps">Coq</span> commands associate automatically a logical path to files in
the repository trees rooted at the directory from where the command is
launched, <code class="docutils literal notranslate"><span class="pre">coqlib/user-contrib/</span></code>, the directories listed in the
<code class="docutils literal notranslate"><span class="pre">$COQPATH</span></code>, <code class="docutils literal notranslate"><span class="pre">${XDG_DATA_HOME}/coq/</span></code> and <code class="docutils literal notranslate"><span class="pre">${XDG_DATA_DIRS}/coq/</span></code>
environment variables (see <a class="reference external" href="http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html">XDG base directory specification</a>)
with the same physical-to-logical translation and with an empty logical prefix.</p>
<p>The command line option <code class="docutils literal notranslate"><span class="pre">-R</span></code> is a variant of <code class="docutils literal notranslate"><span class="pre">-Q</span></code> which has the strictly
same behavior regarding loadpaths, but which also makes the
corresponding <code class="docutils literal notranslate"><span class="pre">.vo</span></code> files available through their short names in a way
not unlike the <code class="docutils literal notranslate"><span class="pre">Import</span></code> command (see <a class="reference internal" href="#import-qualid"><span class="std std-ref">here</span></a>). For instance, <code class="docutils literal notranslate"><span class="pre">-R</span></code> <cite>path</cite> <code class="docutils literal notranslate"><span class="pre">Lib</span></code>
associates to the file path <cite>path</cite><code class="docutils literal notranslate"><span class="pre">/path/fOO/Bar/File.vo</span></code> the logical name
<code class="docutils literal notranslate"><span class="pre">Lib.fOO.Bar.File</span></code>, but allows this file to be accessed through the
short names <code class="docutils literal notranslate"><span class="pre">fOO.Bar.File,Bar.File</span></code> and <code class="docutils literal notranslate"><span class="pre">File</span></code>. If several files with
identical base name are present in different subdirectories of a
recursive loadpath, which of these files is found first may be system-
dependent and explicit qualification is recommended. The <code class="docutils literal notranslate"><span class="pre">From</span></code> argument
of the <code class="docutils literal notranslate"><span class="pre">Require</span></code> command can be used to bypass the implicit shortening
by providing an absolute root to the required file (see <a class="reference internal" href="../proof-engine/vernacular-commands.html#compiled-files"><span class="std std-ref">Compiled files</span></a>).</p>
<p>There also exists another independent loadpath mechanism attached to
OCaml object files (<code class="docutils literal notranslate"><span class="pre">.cmo</span></code> or <code class="docutils literal notranslate"><span class="pre">.cmxs</span></code>) rather than <span class="smallcaps">Coq</span> object
files as described above. The OCaml loadpath is managed using
the option <code class="docutils literal notranslate"><span class="pre">-I</span></code> <cite>path</cite> (in the OCaml world, there is neither a
notion of logical name prefix nor a way to access files in
subdirectories of path). See the command <code class="docutils literal notranslate"><span class="pre">Declare</span></code> <code class="docutils literal notranslate"><span class="pre">ML</span></code> <code class="docutils literal notranslate"><span class="pre">Module</span></code> in
<a class="reference internal" href="../proof-engine/vernacular-commands.html#compiled-files"><span class="std std-ref">Compiled files</span></a> to understand the need of the OCaml loadpath.</p>
<p>See <a class="reference internal" href="../practical-tools/coq-commands.html#command-line-options"><span class="std std-ref">By command line options</span></a> for a more general view over the <span class="smallcaps">Coq</span> command
line options.</p>
</div>
</div>
<div class="section" id="implicit-arguments">
<span id="implicitarguments"></span><h2>Implicit arguments<a class="headerlink" href="#implicit-arguments" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>An implicit argument of a function is an argument which can be
inferred from contextual knowledge. There are different kinds of
implicit arguments that can be considered implicit in different ways.
There are also various commands to control the setting or the
inference of implicit arguments.</p>
<div class="section" id="the-different-kinds-of-implicit-arguments">
<h3>The different kinds of implicit arguments<a class="headerlink" href="#the-different-kinds-of-implicit-arguments" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="section" id="implicit-arguments-inferable-from-the-knowledge-of-other-arguments-of-a-function">
<h4>Implicit arguments inferable from the knowledge of other arguments of a function<a class="headerlink" href="#implicit-arguments-inferable-from-the-knowledge-of-other-arguments-of-a-function" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The first kind of implicit arguments covers the arguments that are
inferable from the knowledge of the type of other arguments of the
function, or of the type of the surrounding context of the
application. Especially, such implicit arguments correspond to
parameters dependent in the type of the function. Typical implicit
arguments are the type arguments in polymorphic functions. There are
several kinds of such implicit arguments.</p>
<p><strong>Strict Implicit Arguments</strong></p>
<p>An implicit argument can be either strict or non strict. An implicit
argument is said to be <em>strict</em> if, whatever the other arguments of the
function are, it is still inferable from the type of some other
argument. Technically, an implicit argument is strict if it
corresponds to a parameter which is not applied to a variable which
itself is another parameter of the function (since this parameter may
erase its arguments), not in the body of a match, and not itself
applied or matched against patterns (since the original form of the
argument can be lost by reduction).</p>
<p>For instance, the first argument of</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>cons: forall A:Set, A -&gt; list A -&gt; list A
</pre></div>
</div>
<p>in module <code class="docutils literal notranslate"><span class="pre">List.v</span></code> is strict because <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">list</span></span></code> is an inductive type and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code>
will always be inferable from the type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">list</span></span> <span class="name"><span class="pre">A</span></span></code> of the third argument of
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">cons</span></span></code>. Also, the first argument of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">cons</span></span></code> is strict with respect to the second one,
since the first argument is exactly the type of the second argument.
On the contrary, the second argument of a term of type</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>forall P:nat-&gt;Prop, forall n:nat, P n -&gt; ex nat P
</pre></div>
</div>
<p>is implicit but not strict, since it can only be inferred from the
type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">n</span></span></code> of the third argument and if <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> is, e.g., <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span> <span class="operator"><span class="pre">_</span></span> <span class="operator"><span class="pre">=&gt;</span></span> <span class="name"><span class="pre">True</span></span></code>, it
reduces to an expression where <code class="docutils literal notranslate"><span class="pre">n</span></code> does not occur any longer. The first
argument <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> is implicit but not strict either because it can only be
inferred from <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">n</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> is not canonically inferable from an arbitrary
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> and the normal form of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">n</span></span></code>. Consider, e.g., that <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> is <span class="math notranslate nohighlight">\(0\)</span> and the third
argument has type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">True</span></span></code>, then any <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> of the form</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>fun n =&gt; match n with 0 =&gt; True | _ =&gt; anything end
</pre></div>
</div>
<p>would be a solution of the inference problem.</p>
<p><strong>Contextual Implicit Arguments</strong></p>
<p>An implicit argument can be <em>contextual</em> or not. An implicit argument
is said <em>contextual</em> if it can be inferred only from the knowledge of
the type of the context of the current expression. For instance, the
only argument of:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>nil : forall A:Set, list A`
</pre></div>
</div>
<p>is contextual. Similarly, both arguments of a term of type:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>forall P:nat-&gt;Prop, forall n:nat, P n \/ n = 0
</pre></div>
</div>
<p>are contextual (moreover, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> is strict and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> is not).</p>
<p><strong>Reversible-Pattern Implicit Arguments</strong></p>
<p>There is another class of implicit arguments that can be reinferred
unambiguously if all the types of the remaining arguments are known.
This is the class of implicit arguments occurring in the type of
another argument in position of reversible pattern, which means it is
at the head of an application but applied only to uninstantiated
distinct variables. Such an implicit argument is called <em>reversible-
pattern implicit argument</em>. A typical example is the argument <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> of
nat_rec in</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>nat_rec : forall P : nat -&gt; Set, P 0 -&gt;
  (forall n : nat, P n -&gt; P (S n)) -&gt; forall x : nat, P x
</pre></div>
</div>
<p>(<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> is reinferable by abstracting over <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> in the type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">n</span></span></code>).</p>
<p>See <a class="reference internal" href="#controlling-rev-pattern-implicit-args"><span class="std std-ref">Controlling reversible-pattern implicit arguments</span></a> for the automatic declaration of reversible-pattern
implicit arguments.</p>
</div>
<div class="section" id="implicit-arguments-inferable-by-resolution">
<h4>Implicit arguments inferable by resolution<a class="headerlink" href="#implicit-arguments-inferable-by-resolution" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>This corresponds to a class of non-dependent implicit arguments that
are solved based on the structure of their type only.</p>
</div>
</div>
<div class="section" id="maximal-or-non-maximal-insertion-of-implicit-arguments">
<h3>Maximal or non maximal insertion of implicit arguments<a class="headerlink" href="#maximal-or-non-maximal-insertion-of-implicit-arguments" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>In case a function is partially applied, and the next argument to be
applied is an implicit argument, two disciplines are applicable. In
the first case, the function is considered to have no arguments
furtherly: one says that the implicit argument is not maximally
inserted. In the second case, the function is considered to be
implicitly applied to the implicit arguments it is waiting for: one
says that the implicit argument is maximally inserted.</p>
<p>Each implicit argument can be declared to have to be inserted maximally or non
maximally. This can be governed argument per argument by the command
<a class="reference internal" href="#coq:cmd.arguments-implicits" title="Arguments (implicits)"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Arguments</span> <span class="pre">(implicits)</span></code></a> or globally by the <a class="reference internal" href="#coq:flag.maximal-implicit-insertion" title="Maximal Implicit Insertion"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Maximal</span> <span class="pre">Implicit</span> <span class="pre">Insertion</span></code></a> option.</p>
<div class="admonition seealso">
<p class="admonition-title">参考</p>
<p><a class="reference internal" href="#displaying-implicit-args"><span class="std std-ref">Displaying what the implicit arguments are</span></a>.</p>
</div>
</div>
<div class="section" id="casual-use-of-implicit-arguments">
<h3>Casual use of implicit arguments<a class="headerlink" href="#casual-use-of-implicit-arguments" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>In a given expression, if it is clear that some argument of a function
can be inferred from the type of the other arguments, the user can
force the given argument to be guessed by replacing it by “_”. If
possible, the correct argument will be automatically generated.</p>
<dl class="exn">
<dt id="coq:exn.cannot-infer-a-term-for-this-placeholder-casual-use-of-implicit-arguments">
<em class="property"><span class="sigannot">Error</span></em> <code class="sig-name descname"><span class="notation"><span>Cannot</span> <span>infer</span> <span>a</span> <span>term</span> <span>for</span> <span>this</span> <span>placeholder.</span></span></code><a class="headerlink" href="#coq:exn.cannot-infer-a-term-for-this-placeholder-casual-use-of-implicit-arguments" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><span class="smallcaps">Coq</span> was not able to deduce an instantiation of a “_”.</p>
</dd></dl>

</div>
<div class="section" id="declaration-of-implicit-arguments">
<span id="declare-implicit-args"></span><h3>Declaration of implicit arguments<a class="headerlink" href="#declaration-of-implicit-arguments" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>In case one wants that some arguments of a given object (constant,
inductive types, constructors, assumptions, local or not) are always
inferred by <span class="smallcaps">Coq</span>, one may declare once and for all which are the
expected implicit arguments of this object. There are two ways to do
this, <em>a priori</em> and <em>a posteriori</em>.</p>
<div class="section" id="implicit-argument-binders">
<h4>Implicit Argument Binders<a class="headerlink" href="#implicit-argument-binders" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>In the first setting, one wants to explicitly give the implicit
arguments of a declared object as part of its definition. To do this,
one has to surround the bindings of implicit arguments by curly
braces:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">id</span><span> {</span><span class="coqdoc-var">A</span><span> : </span><span class="coqdoc-keyword">Type</span><span>} (</span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">A</span><span>) : </span><span class="coqdoc-var">A</span><span> := </span><span class="coqdoc-var">x</span><span>.</span></dt><dd><span>id is defined</span></dd>
</dl>
</div>
<p>This automatically declares the argument A of id as a maximally
inserted implicit argument. One can then do as-if the argument was
absent in every situation but still be able to specify it if needed:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">compose</span><span> {</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">C</span><span>} (</span><span class="coqdoc-var">g</span><span> : </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">C</span><span>) (</span><span class="coqdoc-var">f</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span>) := </span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">x</span><span> =&gt; </span><span class="coqdoc-var">g</span><span> (</span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">x</span><span>).</span></dt><dd><span>compose is defined</span></dd>
<dt><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">A</span><span>, </span><span class="coqdoc-var">compose</span><span> </span><span class="coqdoc-var">id</span><span> </span><span class="coqdoc-var">id</span><span> = </span><span class="coqdoc-var">id</span><span> (</span><span class="coqdoc-var">A</span><span>:=</span><span class="coqdoc-var">A</span><span>).</span></dt><dd><span>1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">compose</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">id</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">id</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">id</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
</dl>
</div>
<p>The syntax is supported in all top-level definitions: <a class="reference internal" href="gallina-specification-language.html#coq:cmd.definition" title="Definition"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Definition</span></code></a>, <a class="reference internal" href="gallina-specification-language.html#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a>, <a class="reference internal" href="gallina-specification-language.html#coq:cmdv.lemma" title="Lemma"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Lemma</span></code></a> and so on. For (co-)inductive datatype declarations, the semantics are the following: an inductive parameter declared as an implicit argument need not be repeated in the inductive definition but will become implicit for the constructors of the inductive only, not the inductive type itself. 例えば:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list</span><span> {</span><span class="coqdoc-var">A</span><span> : </span><span class="coqdoc-keyword">Type</span><span>} : </span><span class="coqdoc-keyword">Type</span><span> :=</span><span>
| </span><span class="coqdoc-var">nil</span><span> : </span><span class="coqdoc-var">list</span><span>
| </span><span class="coqdoc-var">cons</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list</span><span> -&gt; </span><span class="coqdoc-var">list</span><span>.</span></dt><dd><span>list is defined
list_rect is defined
list_ind is defined
list_rec is defined</span></dd>
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">list</span><span>.</span></dt><dd><span class="ansi-fg-light-red ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Inductive</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> list (A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> :=  nil : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> | cons : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

For list: Argument A is implicit and maximally inserted
For nil: Argument A is implicit and maximally inserted
For cons: Argument A is implicit and maximally inserted
For list: Argument scope is [type_scope]
For nil: Argument scope is [type_scope]
For cons: Argument scopes are [type_scope _ _]</span></dd>
</dl>
</div>
<p>One can always specify the parameter if it is not uniform using the
usual implicit arguments disambiguation syntax.</p>
</div>
<div class="section" id="declaring-implicit-arguments">
<h4>Declaring Implicit Arguments<a class="headerlink" href="#declaring-implicit-arguments" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>To set implicit arguments <em>a posteriori</em>, one can use the command:</p>
<dl class="cmd">
<dt id="coq:cmd.arguments-implicits">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Arguments</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span class="repeat-wrapper"><span class="repeat"><span class="hole">possibly_bracketed_ident</span></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:cmd.arguments-implicits" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>where the list of <cite>possibly_bracketed_ident</cite> is a prefix of the list of
arguments of <cite>qualid</cite> where the ones to be declared implicit are
surrounded by square brackets and the ones to be declared as maximally
inserted implicits are surrounded by curly braces.</p>
<p>After the above declaration is issued, implicit arguments can just
(and have to) be skipped in any expression involving an application
of <cite>qualid</cite>.</p>
<p>Implicit arguments can be cleared with the following syntax:</p>
<dl class="cmd">
<dt id="coq:cmd.arguments">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Arguments</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span>:</span> <span>clear</span> <span>implicits</span></span></code><a class="headerlink" href="#coq:cmd.arguments" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Global</span> <span>Arguments</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span class="repeat-wrapper"><span class="repeat"><span class="hole">possibly_bracketed_ident</span></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>Says to recompute the implicit arguments of
<cite>qualid</cite> after ending of the current section if any, enforcing the
implicit arguments known from inside the section to be the ones
declared by the command.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Local</span> <span>Arguments</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span class="repeat-wrapper"><span class="repeat"><span class="hole">possibly_bracketed_ident</span></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>When in a module, tell not to activate the
implicit arguments ofqualid declared by this command to contexts that
require the module.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>Global</span> <span>|</span> <span>Local</span></span><span class="notation-sup">?</span></span> <span>Arguments</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span class="repeat-wrapper"><span class="repeat"><span class="repeat-wrapper"><span class="repeat"><span class="hole">possibly_bracketed_ident</span></span><span class="notation-sup">+</span></span></span><span class="notation-sup">*</span><span class="notation-sub">,</span></span></span></code></dt>
<dd><p>For names of constants, inductive types,
constructors, lemmas which can only be applied to a fixed number of
arguments (this excludes for instance constants whose type is
polymorphic), multiple implicit arguments declarations can be given.
Depending on the number of arguments qualid is applied to in practice,
the longest applicable list of implicit arguments is used to select
which implicit arguments are inserted. For printing, the omitted
arguments are the ones of the longest list of implicit arguments of
the sequence.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Type</span><span>) : </span><span class="coqdoc-keyword">Type</span><span> :=</span><span>
| </span><span class="coqdoc-var">nil</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>
| </span><span class="coqdoc-var">cons</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>.</span></dt><dd><span>list is defined
list_rect is defined
list_ind is defined
list_rec is defined</span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">nat</span><span> 3 (</span><span class="coqdoc-var">nil</span><span> </span><span class="coqdoc-var">nat</span><span>)).</span></dt><dd><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3 (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
<dt><span class="coqdoc-var">Arguments</span><span> </span><span class="coqdoc-var">cons</span><span> [</span><span class="coqdoc-var">A</span><span>] </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">_</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-var">Arguments</span><span> </span><span class="coqdoc-var">nil</span><span> [</span><span class="coqdoc-var">A</span><span>].</span></dt><dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-var">cons</span><span> 3 </span><span class="coqdoc-var">nil</span><span>).</span></dt><dd><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">map</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Type</span><span>) (</span><span class="coqdoc-var">f</span><span>:</span><span class="coqdoc-var">A</span><span>-&gt;</span><span class="coqdoc-var">B</span><span>) (</span><span class="coqdoc-var">l</span><span>:</span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>) : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">B</span><span> := </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">nil</span><span> =&gt; </span><span class="coqdoc-var">nil</span><span> | </span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">t</span><span> =&gt; </span><span class="coqdoc-var">cons</span><span> (</span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">a</span><span>) (</span><span class="coqdoc-var">map</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">t</span><span>) </span><span class="coqdoc-keyword">end</span><span>.</span></dt><dd><span>map is defined
map is recursively defined (decreasing on 4th argument)</span></dd>
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">length</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Type</span><span>) (</span><span class="coqdoc-var">l</span><span>:</span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>) : </span><span class="coqdoc-var">nat</span><span> := </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">nil</span><span> =&gt; 0 | </span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">m</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">length</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">m</span><span>) </span><span class="coqdoc-keyword">end</span><span>.</span></dt><dd><span>length is defined
length is recursively defined (decreasing on 2nd argument)</span></dd>
<dt><span class="coqdoc-var">Arguments</span><span> </span><span class="coqdoc-var">map</span><span> [</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>] </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">l</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-var">Arguments</span><span> </span><span class="coqdoc-var">length</span><span> {</span><span class="coqdoc-var">A</span><span>} </span><span class="coqdoc-var">l</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
<dt><span>
</span><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">l</span><span>:</span><span class="coqdoc-var">list</span><span> (</span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">nat</span><span>) =&gt; </span><span class="coqdoc-var">map</span><span> </span><span class="coqdoc-var">length</span><span> </span><span class="coqdoc-var">l</span><span>).</span></dt><dd><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">map</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">length</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
<dt><span class="coqdoc-var">Arguments</span><span> </span><span class="coqdoc-var">map</span><span> [</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>] </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">l</span><span>, [</span><span class="coqdoc-var">A</span><span>] </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">l</span><span>, </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">l</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">l</span><span> =&gt; </span><span class="coqdoc-var">map</span><span> </span><span class="coqdoc-var">length</span><span> </span><span class="coqdoc-var">l</span><span> = </span><span class="coqdoc-var">map</span><span> (</span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">nat</span><span>) </span><span class="coqdoc-var">nat</span><span> </span><span class="coqdoc-var">length</span><span> </span><span class="coqdoc-var">l</span><span>).</span></dt><dd><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">map</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">length</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">map</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">length</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
</dl>
</div>
</div>
<p>Remark: To know which are the implicit arguments of an object, use the
command <code class="docutils literal notranslate"><span class="pre">Print</span> <span class="pre">Implicit</span></code> (see <a class="reference internal" href="#displaying-implicit-args"><span class="std std-ref">Displaying what the implicit arguments are</span></a>).</p>
</div>
</div>
<div class="section" id="automatic-declaration-of-implicit-arguments">
<h3>Automatic declaration of implicit arguments<a class="headerlink" href="#automatic-declaration-of-implicit-arguments" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><span class="smallcaps">Coq</span> can also automatically detect what are the implicit arguments of a
defined object. The command is just</p>
<dl class="cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Arguments</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span>:</span> <span>default</span> <span>implicits</span></span></code></dt>
<dd></dd></dl>

<p>The auto-detection is governed by options telling if strict,
contextual, or reversible-pattern implicit arguments must be
considered or not (see <a class="reference internal" href="#controlling-strict-implicit-args"><span class="std std-ref">Controlling strict implicit arguments</span></a>, <a class="reference internal" href="#controlling-strict-implicit-args"><span class="std std-ref">Controlling strict implicit arguments</span></a>,
<a class="reference internal" href="#controlling-rev-pattern-implicit-args"><span class="std std-ref">Controlling reversible-pattern implicit arguments</span></a>, and also <a class="reference internal" href="#controlling-insertion-implicit-args"><span class="std std-ref">Controlling the insertion of implicit arguments not followed by explicit arguments</span></a>).</p>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Global</span> <span>Arguments</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span>:</span> <span>default</span> <span>implicits</span></span></code></dt>
<dd><p>Tell to recompute the
implicit arguments of qualid after ending of the current section if
any.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Local</span> <span>Arguments</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span>:</span> <span>default</span> <span>implicits</span></span></code></dt>
<dd><p>When in a module, tell not to activate the implicit arguments of <cite>qualid</cite> computed by this
declaration to contexts that requires the module.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl>
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">nil</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>
| </span><span class="coqdoc-var">cons</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>.</span></dt><dd><span>list is defined
list_rect is defined
list_ind is defined
list_rec is defined</span></dd>
<dt><span class="coqdoc-var">Arguments</span><span> </span><span class="coqdoc-var">cons</span><span> : </span><span class="coqdoc-var">default</span><span> </span><span class="coqdoc-var">implicits</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">cons</span><span>.</span></dt><dd><span>cons : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

Argument A is implicit</span></dd>
<dt><span class="coqdoc-var">Arguments</span><span> </span><span class="coqdoc-var">nil</span><span> : </span><span class="coqdoc-var">default</span><span> </span><span class="coqdoc-var">implicits</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">nil</span><span>.</span></dt><dd><span>nil : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
<dt><span class="coqdoc-keyword">Set</span><span> </span><span class="coqdoc-var">Contextual</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-var">Arguments</span><span> </span><span class="coqdoc-var">nil</span><span> : </span><span class="coqdoc-var">default</span><span> </span><span class="coqdoc-var">implicits</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">nil</span><span>.</span></dt><dd><span>nil : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

Argument A is implicit and maximally inserted</span></dd>
</dl>
</div>
</div>
<p>The computation of implicit arguments takes account of the unfolding
of constants. For instance, the variable <code class="docutils literal notranslate"><span class="pre">p</span></code> below has type
<code class="docutils literal notranslate"><span class="pre">(Transitivity</span> <span class="pre">R)</span></code> which is reducible to
<code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">x,y:U,</span> <span class="pre">R</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">-&gt;</span> <span class="pre">forall</span> <span class="pre">z:U,</span> <span class="pre">R</span> <span class="pre">y</span> <span class="pre">z</span> <span class="pre">-&gt;</span> <span class="pre">R</span> <span class="pre">x</span> <span class="pre">z</span></code>. As the variables <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">z</span></code>
appear strictly in the body of the type, they are implicit.</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="simple">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set</span><span> </span><span class="coqdoc-var">Warnings</span><span> &quot;-local-declaration&quot;.</span></dt><dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl>
<dt><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">X</span><span> : </span><span class="coqdoc-keyword">Type</span><span>.</span></dt><dd><span>X is declared</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">Relation</span><span> := </span><span class="coqdoc-var">X</span><span> -&gt; </span><span class="coqdoc-var">X</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span></dt><dd><span>Relation is defined</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">Transitivity</span><span> (</span><span class="coqdoc-var">R</span><span>:</span><span class="coqdoc-var">Relation</span><span>) := </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>:</span><span class="coqdoc-var">X</span><span>, </span><span class="coqdoc-var">R</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> -&gt; </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">z</span><span>:</span><span class="coqdoc-var">X</span><span>, </span><span class="coqdoc-var">R</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> -&gt; </span><span class="coqdoc-var">R</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">z</span><span>.</span></dt><dd><span>Transitivity is defined</span></dd>
<dt><span class="coqdoc-keyword">Variables</span><span> (</span><span class="coqdoc-var">R</span><span> : </span><span class="coqdoc-var">Relation</span><span>) (</span><span class="coqdoc-var">p</span><span> : </span><span class="coqdoc-var">Transitivity</span><span> </span><span class="coqdoc-var">R</span><span>).</span></dt><dd><span>R is declared
p is declared</span></dd>
<dt><span class="coqdoc-var">Arguments</span><span> </span><span class="coqdoc-var">p</span><span> : </span><span class="coqdoc-var">default</span><span> </span><span class="coqdoc-var">implicits</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">p</span><span>.</span></dt><dd><span>*** [ p : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Transitivity</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> ]

Expanded type for implicit arguments
p : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">X</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">X</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

Arguments x, y, z are implicit</span></dd>
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">p</span><span>.</span></dt><dd><span>p : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">X</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">X</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

Arguments x, y, z are implicit</span></dd>
<dt><span class="coqdoc-keyword">Variables</span><span> (</span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">c</span><span> : </span><span class="coqdoc-var">X</span><span>) (</span><span class="coqdoc-var">r1</span><span> : </span><span class="coqdoc-var">R</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span>) (</span><span class="coqdoc-var">r2</span><span> : </span><span class="coqdoc-var">R</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">c</span><span>).</span></dt><dd><span>a is declared
b is declared
c is declared
r1 is declared
r2 is declared</span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">r1</span><span> </span><span class="coqdoc-var">r2</span><span>).</span></dt><dd><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
</dl>
</div>
</div>
<div class="section" id="mode-for-automatic-declaration-of-implicit-arguments">
<h3>Mode for automatic declaration of implicit arguments<a class="headerlink" href="#mode-for-automatic-declaration-of-implicit-arguments" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="flag">
<dt id="coq:flag.implicit-arguments">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Implicit</span> <span>Arguments</span></span></code><a class="headerlink" href="#coq:flag.implicit-arguments" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This option (off by default) allows to systematically declare implicit
the arguments detectable as such. Auto-detection of implicit arguments is
governed by options controlling whether strict and contextual implicit
arguments have to be considered or not.</p>
</dd></dl>

</div>
<div class="section" id="controlling-strict-implicit-arguments">
<span id="controlling-strict-implicit-args"></span><h3>Controlling strict implicit arguments<a class="headerlink" href="#controlling-strict-implicit-arguments" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="flag">
<dt id="coq:flag.strict-implicit">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Strict</span> <span>Implicit</span></span></code><a class="headerlink" href="#coq:flag.strict-implicit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>When the mode for automatic declaration of implicit arguments is on,
the default is to automatically set implicit only the strict implicit
arguments plus, for historical reasons, a small subset of the non-strict
implicit arguments. To relax this constraint and to set
implicit all non strict implicit arguments by default, you can turn this
option off.</p>
</dd></dl>

<dl class="flag">
<dt id="coq:flag.strongly-strict-implicit">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Strongly</span> <span>Strict</span> <span>Implicit</span></span></code><a class="headerlink" href="#coq:flag.strongly-strict-implicit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Use this option (off by default) to capture exactly the strict implicit
arguments and no more than the strict implicit arguments.</p>
</dd></dl>

</div>
<div class="section" id="controlling-contextual-implicit-arguments">
<span id="controlling-contextual-implicit-args"></span><h3>Controlling contextual implicit arguments<a class="headerlink" href="#controlling-contextual-implicit-arguments" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="flag">
<dt id="coq:flag.contextual-implicit">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Contextual</span> <span>Implicit</span></span></code><a class="headerlink" href="#coq:flag.contextual-implicit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>By default, <span class="smallcaps">Coq</span> does not automatically set implicit the contextual
implicit arguments. You can turn this option on to tell <span class="smallcaps">Coq</span> to also
infer contextual implicit argument.</p>
</dd></dl>

</div>
<div class="section" id="controlling-reversible-pattern-implicit-arguments">
<span id="controlling-rev-pattern-implicit-args"></span><h3>Controlling reversible-pattern implicit arguments<a class="headerlink" href="#controlling-reversible-pattern-implicit-arguments" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="flag">
<dt id="coq:flag.reversible-pattern-implicit">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Reversible</span> <span>Pattern</span> <span>Implicit</span></span></code><a class="headerlink" href="#coq:flag.reversible-pattern-implicit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>By default, <span class="smallcaps">Coq</span> does not automatically set implicit the reversible-pattern
implicit arguments. You can turn this option on to tell <span class="smallcaps">Coq</span> to also infer
reversible-pattern implicit argument.</p>
</dd></dl>

</div>
<div class="section" id="controlling-the-insertion-of-implicit-arguments-not-followed-by-explicit-arguments">
<span id="controlling-insertion-implicit-args"></span><h3>Controlling the insertion of implicit arguments not followed by explicit arguments<a class="headerlink" href="#controlling-the-insertion-of-implicit-arguments-not-followed-by-explicit-arguments" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="flag">
<dt id="coq:flag.maximal-implicit-insertion">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Maximal</span> <span>Implicit</span> <span>Insertion</span></span></code><a class="headerlink" href="#coq:flag.maximal-implicit-insertion" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Assuming the implicit argument mode is on, this option (off by default)
declares implicit arguments to be automatically inserted when a
function is partially applied and the next argument of the function is
an implicit one.</p>
</dd></dl>

</div>
<div class="section" id="explicit-applications">
<span id="id8"></span><h3>Explicit applications<a class="headerlink" href="#explicit-applications" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>In presence of non-strict or contextual argument, or in presence of
partial applications, the synthesis of implicit arguments may fail, so
one may have to give explicitly certain implicit arguments of an
application. The syntax for this is <code class="docutils literal notranslate"><span class="pre">(</span></code> <cite>ident</cite> <code class="docutils literal notranslate"><span class="pre">:=</span></code> <cite>term</cite> <code class="docutils literal notranslate"><span class="pre">)</span></code> where <cite>ident</cite> is the
name of the implicit argument and term is its corresponding explicit
term. Alternatively, one can locally deactivate the hiding of implicit
arguments of a function by using the notation <cite>&#64;qualid</cite> <cite>term</cite><span class="math notranslate nohighlight">\(_{1}\)</span> … <cite>term</cite><span class="math notranslate nohighlight">\(_{n}\)</span>.
This syntax extension is given in the following grammar:</p>
<blockquote id="explicit-app-grammar">
<div><pre>
<strong id="grammar-token-term">term    </strong> ::=  &#64; qualid term … <a class="reference internal" href="gallina-specification-language.html#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
              | &#64; qualid
              | qualid <a class="reference internal" href="#grammar-token-argument"><code class="xref docutils literal notranslate"><span class="pre">argument</span></code></a> … <a class="reference internal" href="#grammar-token-argument"><code class="xref docutils literal notranslate"><span class="pre">argument</span></code></a>
<strong id="grammar-token-argument">argument</strong> ::=  <a class="reference internal" href="gallina-specification-language.html#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
              | (ident := <a class="reference internal" href="gallina-specification-language.html#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>)
</pre>
<p>Syntax for explicitly giving implicit arguments</p>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Example: (continued)</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">r1</span><span> (</span><span class="coqdoc-var">z</span><span>:=</span><span class="coqdoc-var">c</span><span>)).</span></dt><dd><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (z:=</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-var">p</span><span> (</span><span class="coqdoc-var">x</span><span>:=</span><span class="coqdoc-var">a</span><span>) (</span><span class="coqdoc-var">y</span><span>:=</span><span class="coqdoc-var">b</span><span>) </span><span class="coqdoc-var">r1</span><span> (</span><span class="coqdoc-var">z</span><span>:=</span><span class="coqdoc-var">c</span><span>) </span><span class="coqdoc-var">r2</span><span>).</span></dt><dd><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
</dl>
</div>
</div>
</div>
<div class="section" id="renaming-implicit-arguments">
<h3>Renaming implicit arguments<a class="headerlink" href="#renaming-implicit-arguments" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Implicit arguments names can be redefined using the following syntax:</p>
<dl class="cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Arguments</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="gallina-specification-language.html#grammar-token-name"><span class="hole">name</span></a></span><span class="notation-sup">*</span></span> <span>:</span> <span class="hole">rename</span></span></code></dt>
<dd></dd></dl>

<p>With the assert flag, <code class="docutils literal notranslate"><span class="pre">Arguments</span></code> can be used to assert that a given
object has the expected number of arguments and that these arguments
are named as expected.</p>
<div class="admonition note">
<p class="admonition-title">Example: (continued)</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-var">Arguments</span><span> </span><span class="coqdoc-var">p</span><span> [</span><span class="coqdoc-var">s</span><span> </span><span class="coqdoc-var">t</span><span>] </span><span class="coqdoc-var">_</span><span> [</span><span class="coqdoc-var">u</span><span>] </span><span class="coqdoc-var">_</span><span>: </span><span class="coqdoc-tactic">rename</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">r1</span><span> (</span><span class="coqdoc-var">u</span><span>:=</span><span class="coqdoc-var">c</span><span>)).</span></dt><dd><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (u:=</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-var">p</span><span> (</span><span class="coqdoc-var">s</span><span>:=</span><span class="coqdoc-var">a</span><span>) (</span><span class="coqdoc-var">t</span><span>:=</span><span class="coqdoc-var">b</span><span>) </span><span class="coqdoc-var">r1</span><span> (</span><span class="coqdoc-var">u</span><span>:=</span><span class="coqdoc-var">c</span><span>) </span><span class="coqdoc-var">r2</span><span>).</span></dt><dd><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-var">Arguments</span><span> </span><span class="coqdoc-var">p</span><span> [</span><span class="coqdoc-var">s</span><span> </span><span class="coqdoc-var">t</span><span>] </span><span class="coqdoc-var">_</span><span> [</span><span class="coqdoc-var">w</span><span>] </span><span class="coqdoc-var">_</span><span> : </span><span class="coqdoc-tactic">assert</span><span>.</span></dt><dd><span>The command has indeed failed with message:
To rename arguments the &quot;rename&quot; flag must be specified.
Argument u renamed to w.</span></dd>
</dl>
</div>
</div>
</div>
<div class="section" id="displaying-what-the-implicit-arguments-are">
<span id="displaying-implicit-args"></span><h3>Displaying what the implicit arguments are<a class="headerlink" href="#displaying-what-the-implicit-arguments-are" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>To display the implicit arguments associated to an object, and to know
if each of them is to be used maximally or not, use the command</p>
<dl class="cmd">
<dt id="coq:cmd.print-implicit">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Print</span> <span>Implicit</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span></code><a class="headerlink" href="#coq:cmd.print-implicit" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="explicit-displaying-of-implicit-arguments-for-pretty-printing">
<h3>Explicit displaying of implicit arguments for pretty-printing<a class="headerlink" href="#explicit-displaying-of-implicit-arguments-for-pretty-printing" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="flag">
<dt id="coq:flag.printing-implicit">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Printing</span> <span>Implicit</span></span></code><a class="headerlink" href="#coq:flag.printing-implicit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>By default, the basic pretty-printing rules hide the inferable implicit
arguments of an application. Turn this option on to force printing all
implicit arguments.</p>
</dd></dl>

<dl class="flag">
<dt id="coq:flag.printing-implicit-defensive">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Printing</span> <span>Implicit</span> <span>Defensive</span></span></code><a class="headerlink" href="#coq:flag.printing-implicit-defensive" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>By default, the basic pretty-printing rules display the implicit
arguments that are not detected as strict implicit arguments. This
“defensive” mode can quickly make the display cumbersome so this can
be deactivated by turning this option off.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">参考</p>
<p><a class="reference internal" href="#coq:flag.printing-all" title="Printing All"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">All</span></code></a>.</p>
</div>
</div>
<div class="section" id="interaction-with-subtyping">
<h3>Interaction with subtyping<a class="headerlink" href="#interaction-with-subtyping" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>When an implicit argument can be inferred from the type of more than
one of the other arguments, then only the type of the first of these
arguments is taken into account, and not an upper type of all of them.
As a consequence, the inference of the implicit argument of “=” fails
in</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">nat</span><span> = </span><span class="coqdoc-keyword">Prop</span><span>.</span></dt><dd><span>The command has indeed failed with message:
The term &quot;</span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&quot; has type &quot;</span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&quot; while it is expected to have type 
&quot;</span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&quot; (universe inconsistency).</span></dd>
</dl>
</div>
<p>but succeeds in</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-keyword">Prop</span><span> = </span><span class="coqdoc-var">nat</span><span>.</span></dt><dd><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
</dl>
</div>
</div>
<div class="section" id="deactivation-of-implicit-arguments-for-parsing">
<h3>Deactivation of implicit arguments for parsing<a class="headerlink" href="#deactivation-of-implicit-arguments-for-parsing" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="flag">
<dt id="coq:flag.parsing-explicit">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Parsing</span> <span>Explicit</span></span></code><a class="headerlink" href="#coq:flag.parsing-explicit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Turning this option on (it is off by default) deactivates the use of implicit arguments.</p>
<p>In this case, all arguments of constants, inductive types,
constructors, etc, including the arguments declared as implicit, have
to be given as if no arguments were implicit. By symmetry, this also
affects printing.</p>
</dd></dl>

</div>
<div class="section" id="canonical-structures">
<h3>正準構造<a class="headerlink" href="#canonical-structures" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>正準構造とはレコードまたはストラクチャ型のインスタンスの一つであり、それを未知のストラクチャインスタンス (暗黙引数) と値に射影を実行することで単一化問題を解くのに使うことが出来ます。正準構造の完全なドキュメントは <a class="reference internal" href="../addendum/canonical-structures.html#canonicalstructures"><span class="std std-ref">正準構造</span></a> で見つけられます; ここでは単純な例のみを扱います。</p>
<dl class="cmd">
<dt id="coq:cmd.canonical-structure">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Canonical</span> <span>Structure</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span></code><a class="headerlink" href="#coq:cmd.canonical-structure" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このコマンドは <a class="reference internal" href="gallina-specification-language.html#grammar-token-qualid"><code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code></a> を正準構造として定義します。</p>
<p><a class="reference internal" href="gallina-specification-language.html#grammar-token-qualid"><code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code></a> がフィールドが <cite>x</cite><span class="math notranslate nohighlight">\(_{1}\)</span>, …, <cite>x</cite><span class="math notranslate nohighlight">\(_{n}\)</span> であるような構造 <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">struct</span></span></code> の中のあるオブジェクト <code class="docutils literal notranslate"><span class="pre">(Build_struct</span></code> <cite>c</cite><span class="math notranslate nohighlight">\(_{1}\)</span> … <cite>c</cite><span class="math notranslate nohighlight">\(_{n}\)</span> <code class="docutils literal notranslate"><span class="pre">)</span></code> を示すと仮定します。すると、型検査の過程でそれぞれ <code class="docutils literal notranslate"><span class="pre">(</span></code><cite>x</cite><span class="math notranslate nohighlight">\(_{i}\)</span> <code class="docutils literal notranslate"><span class="pre">_)</span></code> <cite>=</cite><span class="math notranslate nohighlight">\(_{\beta\delta\iota\zeta}\)</span> <cite>c</cite><span class="math notranslate nohighlight">\(_{i}\)</span> という形の方程式を解く必要があり、<a class="reference internal" href="gallina-specification-language.html#grammar-token-qualid"><code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code></a> が解として使えます。別の言い方をすると、<a class="reference internal" href="gallina-specification-language.html#grammar-token-qualid"><code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code></a> はフィールド <cite>c</cite><span class="math notranslate nohighlight">\(_{i}\)</span> を <cite>c</cite><span class="math notranslate nohighlight">\(_{i}\)</span> 上に構築した完全な構造に拡張するために規範的に使われました。</p>
<p>正準構造は型強制と厳密暗黙引数と混用したときに特に有用です。</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>これが例です。</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">Relations</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">EqNat</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Structure</span><span> </span><span class="coqdoc-var">Setoid</span><span> : </span><span class="coqdoc-keyword">Type</span><span> := {</span><span class="coqdoc-var">Carrier</span><span> :&gt; </span><span class="coqdoc-keyword">Set</span><span>; </span><span class="coqdoc-var">Equal</span><span> : </span><span class="coqdoc-var">relation</span><span> </span><span class="coqdoc-var">Carrier</span><span>;</span><span>
                            </span><span class="coqdoc-var">Prf_equiv</span><span> : </span><span class="coqdoc-var">equivalence</span><span> </span><span class="coqdoc-var">Carrier</span><span> </span><span class="coqdoc-var">Equal</span><span>}.</span></dt><dd><span>Setoid is defined
Carrier is defined
Equal is defined
Prf_equiv is defined</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">is_law</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-var">Setoid</span><span>) (</span><span class="coqdoc-var">f</span><span>:</span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span>) := </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>:</span><span class="coqdoc-var">A</span><span>, </span><span class="coqdoc-var">Equal</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> -&gt; </span><span class="coqdoc-var">Equal</span><span> (</span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">x</span><span>) (</span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">y</span><span>).</span></dt><dd><span>is_law is defined</span></dd>
<dt><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">eq_nat_equiv</span><span> : </span><span class="coqdoc-var">equivalence</span><span> </span><span class="coqdoc-var">nat</span><span> </span><span class="coqdoc-var">eq_nat</span><span>.</span></dt><dd><span>eq_nat_equiv is declared</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">nat_setoid</span><span> : </span><span class="coqdoc-var">Setoid</span><span> := </span><span class="coqdoc-var">Build_Setoid</span><span> </span><span class="coqdoc-var">eq_nat_equiv</span><span>.</span></dt><dd><span>nat_setoid is defined</span></dd>
<dt><span class="coqdoc-keyword">Canonical</span><span> </span><span class="coqdoc-keyword">Structure</span><span> </span><span class="coqdoc-var">nat_setoid</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
</dl>
</div>
<p><code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_setoid</span></span></code> が正準として定義されているおかげで、次のステートメント内で暗黙引数 <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code> と <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code> が合成できます。</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">is_law_S</span><span> : </span><span class="coqdoc-var">is_law</span><span> </span><span class="coqdoc-var">S</span><span>.</span></dt><dd><span>1 subgoal
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">is_law</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (A:=</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat_setoid</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (B:=</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat_setoid</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>いくつかの正準構造に同じフィールドが現れた場合は、初めに定義された構造のみが正準と認められます。</p>
</div>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Canonical</span> <span>Structure</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>これは <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> の通常の定義に続いて <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">Canonical</span></span> <span><span class="pre">Structure</span></span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> を定義したのと等しくなります。</p>
</dd></dl>

</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.print-canonical-projections">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Print</span> <span>Canonical</span> <span>Projections</span></span></code><a class="headerlink" href="#coq:cmd.print-canonical-projections" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これはいくつかの正準構造のコンポーネントのグローバルな名前のリストを表示します。それぞれについて、その正準構造が射影であるということを示しています。</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>例えば、上の例は以下の出力を与えます。</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">Canonical</span><span> </span><span class="coqdoc-var">Projections</span><span>.</span></dt><dd><span>nat &lt;- Carrier ( </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat_setoid</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> )
eq_nat &lt;- Equal ( </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat_setoid</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> )
eq_nat_equiv &lt;- Prf_equiv ( </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat_setoid</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> )</span></dd>
</dl>
</div>
</div>
</dd></dl>

</div>
<div class="section" id="implicit-types-of-variables">
<h3>変数の暗黙の型<a class="headerlink" href="#implicit-types-of-variables" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>変数名を与えられた型に束縛することが可能です (例: 算術を使う開発の中で、名前 <cite>n</cite> や <cite>m</cite> を自然数である <code class="docutils literal notranslate"><span class="pre">nat</span></code> 型に束縛すると便利かもしれません)そのためのコマンドは</p>
<dl class="cmd">
<dt id="coq:cmd.implicit-types">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Implicit</span> <span>Types</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmd.implicit-types" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>このコマンドの効果は <cite>ident</cite> で始まる (<cite>ident</cite> 自身または <cite>ident</cite> に一つ以上のシングルクォート、アンダースコア、数字が続く) 束縛変数の型を自動的に <cite>type</cite> (その束縛変数が明示的な型とともに既に定義されている場合でない限り、後者の型と見なされる) に設定するものです。</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">List</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-keyword">Types</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span> : </span><span class="coqdoc-var">nat</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">cons_inj_nat</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">l</span><span>, </span><span class="coqdoc-var">n</span><span> :: </span><span class="coqdoc-var">l</span><span> = </span><span class="coqdoc-var">m</span><span> :: </span><span class="coqdoc-var">l</span><span> -&gt; </span><span class="coqdoc-var">n</span><span> = </span><span class="coqdoc-var">m</span><span>.</span></dt><dd><span>1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (m n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">), </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">:: </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">:: </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
<dt><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span>.</span></dt><dd><span>1 subgoal
  
  m, n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">:: </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">:: </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">cons_inj_bool</span><span> : </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">bool</span><span>) </span><span class="coqdoc-var">l</span><span>, </span><span class="coqdoc-var">n</span><span> :: </span><span class="coqdoc-var">l</span><span> = </span><span class="coqdoc-var">m</span><span> :: </span><span class="coqdoc-var">l</span><span> -&gt; </span><span class="coqdoc-var">n</span><span> = </span><span class="coqdoc-var">m</span><span>.</span></dt><dd><span>1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (m n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">), </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">:: </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">:: </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span></dd>
</dl>
</div>
</div>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Implicit</span> <span>Type</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a></span></code></dt>
<dd><p>これは単一の変数の暗黙型を定義するのに有効です。</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Implicit</span> <span>Types</span> <span class="repeat-wrapper"><span class="repeat"><span>(</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>異なる仕様を伴った暗黙型のブロックを追加します。</p>
</dd></dl>

</div>
<div class="section" id="implicit-generalization">
<span id="id9"></span><h3>暗黙の一般化<a class="headerlink" href="#implicit-generalization" title="このヘッドラインへのパーマリンク">¶</a></h3>
<span class="target" id="index-0"></span><p id="index-1">暗黙の一般化とは自由変数を伴う式をこれらの変数が明示的に量化された閉じた文への自動的な詳細化です。暗黙の一般化は ` から始まる束縛子と `{ } と `( ) で区切られている項の中で行われ、一般化された変数について常に最大限に暗黙引数が挿入されます。暗黙の一般化デリミタの中では、現在のコンテキスト中の自由変数は、閉じた項を生成するために積またはラムダ抽象を使うことで自動的に量化されます。例えば以下の文では、`( ) を使うことで変数 n と m は自動的に一般化され、そしてその補題の明示的引数になります。</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Generalizable</span><span> </span><span class="coqdoc-keyword">All</span><span> </span><span class="coqdoc-keyword">Variables</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">nat_comm</span><span> : `(</span><span class="coqdoc-var">n</span><span> = </span><span class="coqdoc-var">n</span><span> + 0).</span></dt><dd><span>1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span></dd>
</dl>
</div>
<p>ヴァーナキュラーコマンド <code class="docutils literal notranslate"><span class="pre">Generalizable</span></code> によって一般化できる識別子の集合をコントロールし、識別子を打ち間違えた時に望まない一般化を避けることが出来ます。どの変数が一般化されるべきかを指定するコマンドがいくつかあります。</p>
<dl class="cmd">
<dt id="coq:cmd.generalizable-all-variables">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Generalizable</span> <span>All</span> <span>Variables</span></span></code><a class="headerlink" href="#coq:cmd.generalizable-all-variables" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>全ての変数は一般化デリミタの中の文脈で自由に出現するならば一般化の候補になります。これはtypoした場合に紛らわしいエラーにつながるかもしれません。そのような場合、恐らく文脈にいくつかの意図しない一般化された変数が含まれています。</p>
</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.generalizable-no-variables">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Generalizable</span> <span>No</span> <span>Variables</span></span></code><a class="headerlink" href="#coq:cmd.generalizable-no-variables" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>暗黙の一般化を完全に無効にします。これはデフォルトの振る舞いです。</p>
</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.generalizable">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Generalizable</span> <span>(Variable</span> <span>|</span> <span>Variables)</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmd.generalizable" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられた識別子のみについて一般化を許可します。このコマンドの複数回呼ぶと許可された識別子へ追加します。</p>
</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.global-generalizable">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Global</span> <span>Generalizable</span></span></code><a class="headerlink" href="#coq:cmd.global-generalizable" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>一般化可能変数についての選択をエクスポートします。</p>
</dd></dl>

<p>束縛子にも暗黙の一般化を使うことができ、その場合は一般化された変数が束縛子として追加され最大限暗黙に設定されます。</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">id</span><span> `(</span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">A</span><span>) : </span><span class="coqdoc-var">A</span><span> := </span><span class="coqdoc-var">x</span><span>.</span></dt><dd><span>id is defined</span></dd>
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">id</span><span>.</span></dt><dd><span>id = </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (x : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

Argument A is implicit and maximally inserted
Argument scopes are [type_scope _]</span></dd>
</dl>
</div>
<p>一般化された束縛子 `{ } や `( ) はそれらの明示的な場合の対応部分と同じように動作し、一般化された変数を最大限挿入された引数として暗黙に束縛するだけです。これらの束縛子の中では、束縛されたオブジェクトの束縛名はオプショナルですが、一方でその型は強制であり、通常の束縛子と双対的です。</p>
</div>
</div>
<div class="section" id="coercions">
<span id="id10"></span><h2>コアーション<a class="headerlink" href="#coercions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>コアーションは項をそれが属するある一つの <em>クラス</em> からもう一つのそれに暗黙的に埋め込むのに使うことが出来ます。<em>クラス</em> はソート (<code class="docutils literal notranslate"><span class="pre">Sortclass</span></code> キーワードで表現される) か、積型 (<code class="docutils literal notranslate"><span class="pre">Funclass</span></code> キーワードで表現される) か、または型構築子 (その名前で表現される) のいずれかであり、例えば、帰納型や <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">(</span></code> <cite>x</cite><span class="math notranslate nohighlight">\(_{1}\)</span> : <cite>A</cite><span class="math notranslate nohighlight">\(_{1}\)</span> ) … <code class="docutils literal notranslate"><span class="pre">(</span></code><cite>x</cite><span class="math notranslate nohighlight">\(_{n}\)</span> : <cite>A</cite><span class="math notranslate nohighlight">\(_{n}\)</span><code class="docutils literal notranslate"><span class="pre">)</span></code>, <cite>s</cite> ここで <cite>s</cite> はソートであるような形式の型を伴う任意の定数です。</p>
<p>するとユーザは関数ではないが、関数にコアーションされるオブジェクトを適用することが出来、さらに一般的にはこう考えられる。ある項の型は <code class="docutils literal notranslate"><span class="pre">A</span></code> であり、<code class="docutils literal notranslate"><span class="pre">A</span></code> と <code class="docutils literal notranslate"><span class="pre">B</span></code> の間に定義されたコアーションがあることで提供される型 <code class="docutils literal notranslate"><span class="pre">B</span></code> である。</p>
<p>より詳細と例、それにコアーションに関連するコマンドの説明は <a class="reference internal" href="../addendum/implicit-coercions.html#implicitcoercions"><span class="std std-ref">Implicit Coercions</span></a> で提供されます。</p>
</div>
<div class="section" id="printing-constructions-in-full">
<span id="printing-constructions-full"></span><h2>全ての構成を表示する<a class="headerlink" href="#printing-constructions-in-full" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="flag">
<dt id="coq:flag.printing-all">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Printing</span> <span>All</span></span></code><a class="headerlink" href="#coq:flag.printing-all" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コアーション、暗黙引数、パターンマッチングの型、そればかりでなく表記法 (<a class="reference internal" href="../user-extensions/syntax-extensions.html#syntaxextensionsandinterpretationscopes"><span class="std std-ref">Syntax extensions and interpretation scopes</span></a> 参照) もいくつかのタクティックの振る舞いを分かりにくくし得ます (典型的には部分項の出現に適用するタクティックは暗黙引数に対して敏感です)。このオプションを有効にするとコアーション、暗黙引数、パターンマッチングの戻り型、表記法、それにパターンマッチやレコード射影のための様々な糖衣構文などの全ての高レベル表示機能を解除します。他の言い方をすると <a class="reference internal" href="#coq:flag.printing-all" title="Printing All"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">All</span></code></a> はオプション <a class="reference internal" href="#coq:flag.printing-implicit" title="Printing Implicit"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">Implicit</span></code></a>、<a class="reference internal" href="../addendum/implicit-coercions.html#coq:flag.printing-coercions" title="Printing Coercions"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">Coercions</span></code></a>、<a class="reference internal" href="#coq:flag.printing-synth" title="Printing Synth"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">Synth</span></code></a>、<a class="reference internal" href="#coq:flag.printing-projections" title="Printing Projections"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">Projections</span></code></a>、<a class="reference internal" href="../user-extensions/syntax-extensions.html#coq:flag.printing-notations" title="Printing Notations"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">Notations</span></code></a> の効果を含んでいます。高レベル表示機能を再度有効化するには、<code class="docutils literal notranslate"><span class="pre">Unset</span> <span class="pre">Printing</span> <span class="pre">All</span></code> コマンドを使います。</p>
</dd></dl>

</div>
<div class="section" id="printing-universes">
<span id="id11"></span><h2>ユニバースを表示する<a class="headerlink" href="#printing-universes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="flag">
<dt id="coq:flag.printing-universes">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Printing</span> <span>Universes</span></span></code><a class="headerlink" href="#coq:flag.printing-universes" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このオプションをオンにすると、出現したそれぞれの <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Type</span></span></code> の実際のレベルの表示を有効化します。詳細については <a class="reference internal" href="cic.html#sorts"><span class="std std-ref">Sorts</span></a> を参照してください。この達人向けオプションは、<a class="reference internal" href="#coq:flag.printing-all" title="Printing All"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">All</span></code></a> と組み合わせて一見したところ同じだが Calculus of Inductive Constructions では内部的に異なっている項の単一化の失敗を診断するのに役立ちます。</p>
</dd></dl>

<p>Type の出現の内部的なレベルについての制約 (<a class="reference internal" href="cic.html#sorts"><span class="std std-ref">Sorts</span></a> 参照) はこのコマンドを使うことで表示できます。</p>
<dl class="cmd">
<dt id="coq:cmd.print-universes">
<em class="property"><span class="sigannot">Command</span></em> <code class="sig-name descname"><span class="notation"><span>Print</span> <span class="repeat-wrapper"><span class="repeat"><span>Sorted</span></span><span class="notation-sup">?</span></span> <span>Universes</span></span></code><a class="headerlink" href="#coq:cmd.print-universes" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>オプショナルな <code class="docutils literal notranslate"><span class="pre">Sorted</span></code> オプションが与えられると、各ユニバースは宇宙の階層内での (線形順序付けによる) レベルを反映した番号付きラベルに相当するようになります。</p>
<p>このコマンドはオプショナルな出力ファイル名も受け付けます。</p>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="sig-name descname"><span class="notation"><span>Print</span> <span class="repeat-wrapper"><span class="repeat"><span>Sorted</span></span><span class="notation-sup">?</span></span> <span>Universes</span> <a class="reference internal" href="gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a></span></code></dt>
<dd></dd></dl>

<p><cite>string</cite> が <code class="docutils literal notranslate"><span class="pre">.dot</span></code> や <code class="docutils literal notranslate"><span class="pre">.gv</span></code> で終わっていたら、制約がDOT言語で出力され、Graphviz ツールで処理できるようになります。<cite>string</cite> が <code class="docutils literal notranslate"><span class="pre">.dot</span></code> または <code class="docutils literal notranslate"><span class="pre">.gv</span></code> で終わらない場合はフォーマットは指定されません。</p>
</div>
<div class="section" id="existential-variables">
<span id="id12"></span><h2>Existential variables<a class="headerlink" href="#existential-variables" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><span class="smallcaps">Coq</span> terms can include existential variables which represents unknown
subterms to eventually be replaced by actual subterms.</p>
<p>Existential variables are generated in place of unsolvable implicit
arguments or “_” placeholders when using commands such as <code class="docutils literal notranslate"><span class="pre">Check</span></code> (see
Section <a class="reference internal" href="../proof-engine/vernacular-commands.html#requests-to-the-environment"><span class="std std-ref">Requests to the environment</span></a>) or when using tactics such as
<a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.refine" title="refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">refine</span></code></a>, as well as in place of unsolvable instances when using
tactics such that <a class="reference internal" href="../proof-engine/tactics.html#coq:tacv.eapply" title="eapply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eapply</span></code></a>. An existential
variable is defined in a context, which is the context of variables of
the placeholder which generated the existential variable, and a type,
which is the expected type of the placeholder.</p>
<p>As a consequence of typing constraints, existential variables can be
duplicated in such a way that they possibly appear in different
contexts than their defining context. Thus, any occurrence of a given
existential variable comes with an instance of its original context.
In the simple case, when an existential variable denotes the
placeholder which generated it, or is used in the same context as the
one in which it was generated, the context is not displayed and the
existential variable is represented by “?” followed by an identifier.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">identity</span><span> : </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">X</span><span>:</span><span class="coqdoc-keyword">Set</span><span>), </span><span class="coqdoc-var">X</span><span> -&gt; </span><span class="coqdoc-var">X</span><span>.</span></dt><dd><span>identity is declared</span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">identity</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">_</span><span>.</span></dt><dd><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">identity</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?X</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&#64;{x:=</span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">}
where
?y : [ |- </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?X</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">]
?P : [ |- </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">]
?X : [x : </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> |- </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">]
?x : [ |- </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">]</span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">identity</span><span> </span><span class="coqdoc-var">_</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">x</span><span> =&gt; </span><span class="coqdoc-var">_</span><span>).</span></dt><dd><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">identity</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?y0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)
     : </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?X</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&#64;{x:=</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?y0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">}
where
?y : [ |- </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?P0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?X</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">]
?X : [x : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?P0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> |- </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">]
?P : [ |- </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">]
?P0 : [x : </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> |- </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">]
?y0 : [x : </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> |- </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?P0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">]</span></dd>
</dl>
</div>
<p>In the general case, when an existential variable <code class="docutils literal notranslate"><span class="pre">?</span></code><cite>ident</cite> appears
outside of its context of definition, its instance, written under the
form</p>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">{</span></code> <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">:=</span></span><a class="reference internal" href="gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span><span class="notation-sub"><span class="pre">;</span></span></span></span></code> <code class="docutils literal notranslate"><span class="pre">}</span></code></div>
</div>
<p>is appending to its name, indicating how the variables of its defining context are instantiated.
The variables of the context of the existential variables which are
instantiated by themselves are not written, unless the flag <a class="reference internal" href="#coq:flag.printing-existential-instances" title="Printing Existential Instances"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">Existential</span> <span class="pre">Instances</span></code></a>
is on (see Section <a class="reference internal" href="#explicit-display-existentials"><span class="std std-ref">Explicit displaying of existential instances for pretty-printing</span></a>), and this is why an
existential variable used in the same context as its context of definition is written with no instance.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> =&gt; </span><span class="coqdoc-var">_</span><span>) 0 1.</span></dt><dd><span>(</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) 0 1
     : </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?T</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&#64;{x:=0; y:=1}
where
?T : [x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">  y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> |- </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">]
?y : [x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">  y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> |- </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?T</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">]</span></dd>
<dt><span class="coqdoc-keyword">Set</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-var">Existential</span><span> </span><span class="coqdoc-var">Instances</span><span>.</span></dt><dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> =&gt; </span><span class="coqdoc-var">_</span><span>) 0 1.</span></dt><dd><span>(</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&#64;{x:=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">; y:=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">}) 0 1
     : </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?T</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&#64;{x:=0; y:=1}
where
?T : [x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">  y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> |- </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">]
?y : [x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">  y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> |- </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?T</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&#64;{x:=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">; y:=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">}]</span></dd>
</dl>
</div>
<p>Existential variables can be named by the user upon creation using
the syntax <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">?[</span></span><a class="reference internal" href="gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">]</span></span></span></code>. This is useful when the existential
variable needs to be explicitly handled later in the script (e.g.
with a named-goal selector, see <a class="reference internal" href="../proof-engine/ltac.html#goal-selectors"><span class="std std-ref">Goal selectors</span></a>).</p>
<div class="section" id="explicit-displaying-of-existential-instances-for-pretty-printing">
<span id="explicit-display-existentials"></span><h3>Explicit displaying of existential instances for pretty-printing<a class="headerlink" href="#explicit-displaying-of-existential-instances-for-pretty-printing" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="flag">
<dt id="coq:flag.printing-existential-instances">
<em class="property"><span class="sigannot">Flag</span></em> <code class="sig-name descname"><span class="notation"><span>Printing</span> <span>Existential</span> <span>Instances</span></span></code><a class="headerlink" href="#coq:flag.printing-existential-instances" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This option (off by default) activates the full display of how the
context of an existential variable is instantiated at each of the
occurrences of the existential variable.</p>
</dd></dl>

</div>
<div class="section" id="solving-existential-variables-using-tactics">
<h3>Solving existential variables using tactics<a class="headerlink" href="#solving-existential-variables-using-tactics" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Instead of letting the unification engine try to solve an existential
variable by itself, one can also provide an explicit hole together
with a tactic to solve it. Using the syntax <code class="docutils literal notranslate"><span class="pre">ltac:(</span></code><cite>tacexpr</cite><code class="docutils literal notranslate"><span class="pre">)</span></code>, the user
can put a tactic anywhere a term is expected. The order of resolution
is not specified and is implementation-dependent. The inner tactic may
use any variable defined in its scope, including repeated alternations
between variables introduced by term binding as well as those
introduced by tactic binding. The expression <cite>tacexpr</cite> can be any tactic
expression as described in <a class="reference internal" href="../proof-engine/ltac.html#ltac"><span class="std std-ref">The tactic language</span></a>.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">foo</span><span> (</span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">nat</span><span>) : </span><span class="coqdoc-var">nat</span><span> := </span><span class="coqdoc-keyword">ltac</span><span>:(</span><span class="coqdoc-tactic">exact</span><span> </span><span class="coqdoc-var">x</span><span>).</span></dt><dd><span>identity is declared
foo is defined</span></dd>
</dl>
</div>
<p>This construction is useful when one wants to define complicated terms
using highly automated tactics without resorting to writing the proof-term
by means of the interactive proof engine.</p>
<p>This mechanism is comparable to the <code class="docutils literal notranslate"><span class="pre">Declare</span> <span class="pre">Implicit</span> <span class="pre">Tactic</span></code> command
defined at <a class="reference internal" href="../proof-engine/tactics.html#tactics-implicit-automation"><span class="std std-ref">Setting implicit automation tactics</span></a>, except that the used
tactic is local to each hole instead of being declared globally.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="coq-library.html" class="btn btn-neutral float-right" title="The Coq library" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="gallina-specification-language.html" class="btn btn-neutral float-left" title="仕様記述言語 Gallina" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 1999-2018, Inria

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>